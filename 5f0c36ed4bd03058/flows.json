[{"id":"5f0c36ed4bd03058","type":"tab","label":"[babylonjs] 3D Node-RED Flow","disabled":false,"info":"::: aim\n\nRender flows into a 3D scene using BabylonJS.\n\n:::\n\n::: requirements\n\n- [introspection nodes](https://flows.nodered.org/node/@gregoriusrippenstein/node-red-contrib-introspection)\n\n:::\n\n::: warning\n\nThis will open a http endpoint on your Node-RED installation. It will be available under the `/3dflows/` path.\n\n:::\n\n### Usage\n\nThere are two ways of using this flow, one is to use the <a class=\"ahl-node-only\" data-ids=\"619fbdb53fa2ad98\">generate button</a> that will copy the code into the pasteboard. That code can then be pasted into the [BabylonJS](https://playground.babylonjs.com/) playground (select-all and paste).\n\nThe other way to use this flow is to connect to the http endpoint `http://noderedhost:1880/3dflows/<flowid>` - flowid being the id in the tab url.\n\n`flowid` can also be \"all\" and then all flows are rendered.\n\n### Authentication\n\nIf you use authentication on your Node-RED instance, then you will need to update the <a class=\"ahl-node-only\" data-ids=\"8d0e4f577a13ef8d,f4a532b31106c966\">GetFlow</a> nodes with that authentication.\n\n### Controls\n\nArrow keys to rotate, mouse to drag/pan model and scroll-wheel to zoom in and out.\n\n### Description\n\nWhat this does is take the JSON data of all the flows and layer each flow onto a Z plane upon which the nodes of the flow are rendered. Wires are drawn to connect nodes on the same plane.\n\n### Preview\n\n![img](https://cdn.openmindmap.org/content/1700401826693_3dflow-6.gif)\n\nThe flow show there is [this one](https://flowhub.org/f/741c6acbed17d504).\n","env":[]},{"id":"f02d93a56502e483","type":"group","z":"5f0c36ed4bd03058","name":"websockets for updates for 3d rendering","style":{"label":true},"nodes":["8395478f3fc897f3","e0e7f140354ff1db","3c3b43ba91bfcd40","5932a19455e61097","463c51a486c3925c","342f5b551d4717a9","fc66b2501a7e22e3","e8db65f9438f2b21","c658b245f674c7b1","a62f5d55793a72a8","4a6bab7124c86673","51d0a5ffe2d6a314","eba6a680c523ca75","bbf1ee13e84f420b"],"x":214.5,"y":1641.24755859375,"w":1436.9542236328125,"h":434.75244140625},{"id":"c56b03f32ebdbd8b","type":"junction","z":"5f0c36ed4bd03058","x":304.5688651204109,"y":401.7675850391388,"wires":[["9d1a759fe0ffbc4c"]]},{"id":"7ba1e1d83b6c84e4","type":"junction","z":"5f0c36ed4bd03058","x":304.5688651204109,"y":501.54663690924644,"wires":[["c56b03f32ebdbd8b"]]},{"id":"ba6b8cbcd832bfe3","type":"junction","z":"5f0c36ed4bd03058","x":304.5688651204109,"y":601.3256887793541,"wires":[["7ba1e1d83b6c84e4"]]},{"id":"3cb8aa41602241ea","type":"junction","z":"5f0c36ed4bd03058","x":304.5688651204109,"y":701.1047406494617,"wires":[["ba6b8cbcd832bfe3"]]},{"id":"3a5c2a522d67e5ac","type":"junction","z":"5f0c36ed4bd03058","x":304.5688651204109,"y":800.8837925195694,"wires":[["3cb8aa41602241ea"]]},{"id":"864e6d3ca661fe30","type":"junction","z":"5f0c36ed4bd03058","x":304.5688651204109,"y":900.662844389677,"wires":[["3a5c2a522d67e5ac"]]},{"id":"1fdf35deee4aa072","type":"junction","z":"5f0c36ed4bd03058","x":304.5688651204109,"y":1100.2209481298923,"wires":[["e40914e320ddc51b"]]},{"id":"e40914e320ddc51b","type":"junction","z":"5f0c36ed4bd03058","x":304.5688651204109,"y":1000.4418962597847,"wires":[["864e6d3ca661fe30"]]},{"id":"b6632ef77c8a0735","type":"junction","z":"5f0c36ed4bd03058","x":304.5688651204109,"y":1200,"wires":[["1fdf35deee4aa072"]]},{"id":"7bd729760cb32436","type":"function","z":"5f0c36ed4bd03058","name":"generate 3d world from all flows","func":"let mesh = [];\nlet nodes = {};\n\nlet zValues = {};\n\n// for each flow (i.e. `z` value), compute a position in 3D space.\n// Specifically the flows are layered in the z-axis\nmsg.payload.forEach((nd) => {\n    zValues[nd.z] = zValues[nd.z] || (\n        Math.max.apply(Math, Object.values(zValues).concat([0])) + 100\n    )\n})\n\nmsg.payload.forEach((nd) => {\n    if (nd && nd.x && nd.y) {\n        nd.l = Math.max( 20, (nd.name || nd.info || \"\").length )\n\n        nd.x = (nd.x - 2500) * 1\n        nd.y = (nd.y - 2500) * -1\n        nd.z = zValues[nd.z];\n\n        nd.width = nd.l * 10\n\n        nd.ports = {\n            output: {\n                x: nd.x + nd.width/2,\n                y: nd.y,\n            },\n            input: {\n                x: nd.x - nd.width / 2,\n                y: nd.y\n            }\n        }\n\n        mesh.push(`\n    box = BABYLON.MeshBuilder.CreateBox(\"${nd.id}\", {...options, width: ${nd.width}, height: 30, depth: 50}, scene);\n    box.material = mat;\n    box.position.x = ${nd.x};\n    box.position.y = ${nd.y};\n    box.position.z = ${nd.z};\n        `\n        )\n        nodes[nd.id] = nd\n    }\n})\n\nmsg.payload.forEach(nd => {\n    if (nd && nd.wires) {\n        for (var pCnt = 0; pCnt < nd.wires.length; pCnt++) {\n            for (var wCnt = 0; wCnt < nd.wires[pCnt].length; wCnt++) {\n                let otherNode = nodes[nd.wires[pCnt][wCnt]]\n                if (otherNode) {\n                    mesh.push(`\n                p1 = new BABYLON.Vector3(${nd.ports.output.x}, ${nd.ports.output.y}, ${nd.z});\n                t1 = new BABYLON.Vector3(${nd.ports.output.x}, ${nd.ports.output.y}, ${nd.z});\n                p2 = new BABYLON.Vector3(${otherNode.ports.input.x}, ${otherNode.ports.input.y}, ${otherNode.z});\n                t2 = new BABYLON.Vector3(${otherNode.ports.input.x}, ${otherNode.ports.input.y}, ${otherNode.z});\n                hermite = BABYLON.Curve3.CreateHermiteSpline(p1, t1, p2, t2, 50);\n\n                BABYLON.Mesh.CreateLines(\"${nd.id}-${otherNode.id}\", hermite.getPoints(), scene).color = new BABYLON.Color3(1, 0.6, 0);\n                `)\n                }\n            }\n        }\n    }\n})\n\nmsg.payload.forEach((nd) => {\n    if (nd && nd.x && nd.y) {\n        nd.t = (nd.name || nd.info || \"\").replaceAll('\"',\"\\\\\\\"\").replaceAll(\"\\n\",\"\\\\n\")\n\n        if ( nd.t != \"\" ) {\n            mesh.push(`\n                makeTextPlane(\"${nd.t}\", \"red\", 100).position = new BABYLON.Vector3(${nd.x}, ${nd.y}, ${nd.z});\n            `\n            )\n        }\n    }\n})\n\nmsg.payload = mesh.join(\"\\n\")\n\nreturn msg","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[{"var":"path","module":"path"}],"x":1334.33349609375,"y":425.91668701171875,"wires":[["2cec9e6087c80e12"]]},{"id":"619fbdb53fa2ad98","type":"inject","z":"5f0c36ed4bd03058","name":"generate babylonjs code","props":[],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":487.3139476603301,"y":248.10610686216614,"wires":[["8d0e4f577a13ef8d"]]},{"id":"8d0e4f577a13ef8d","type":"GetFlows","z":"5f0c36ed4bd03058","name":"","flowVersion":"v1","useAuthentication":false,"apiUsername":"","apiUsernameType":"cred","apiPassword":"","apiPasswordType":"cred","x":765.3899057999542,"y":323.5286688969809,"wires":[["334de86f03227cd8"]]},{"id":"334de86f03227cd8","type":"json","z":"5f0c36ed4bd03058","name":"","property":"payload","action":"obj","pretty":false,"x":1022.455473418398,"y":411.3967162161689,"wires":[["7bd729760cb32436","9f6ee13a0817687d"]]},{"id":"2cec9e6087c80e12","type":"template","z":"5f0c36ed4bd03058","name":"babylonjs createScene function","field":"payload","fieldType":"msg","format":"javascript","syntax":"mustache","template":"var createScene = function () {\n    var scene = new BABYLON.Scene(engine);\n    scene.clearColor = new BABYLON.Color3(.5, .5, .5);\n\n    var camera = new BABYLON.UniversalCamera(\"camera1\", new BABYLON.Vector3(0, 0, -0), scene, true);\n    //camera.setTarget(BABYLON.Vector3.Zero());\n    camera.attachControl(canvas, true);\n    camera.inputs.addMouseWheel();\n    //camera.inputs.attached[\"mousewheel\"].wheelPrecisionY = -1;\n\n    var light1 = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(1, 1, 0), scene);\n    var light2 = new BABYLON.PointLight(\"light2\", new BABYLON.Vector3(0, 1, -1), scene);\n\n    const options = {\n        wrap: false,\n        width: 3,\n        updatable: true,\n        faceColors: [\n            new BABYLON.Color4(0.81, 0.08, 0.46, 0.3),\n            new BABYLON.Color4(0.9, 0.08, 0.55, 0.84),\n            new BABYLON.Color4(0.91, 0.57, 0.07),\n            new BABYLON.Color4(0.09, 0.16, 0.77, 0.73),\n            new BABYLON.Color4(0.11, 1, 0.23, 0.77),\n            new BABYLON.Color4(0.81, 0.15, 0.1, 0.3),\n        ]\n    };\n\n    let mat = new BABYLON.StandardMaterial(\"fubar\", scene);\n    mat.diffuseColor = new BABYLON.Color3(0.9, 1, 0)\n    mat.specularColor = new BABYLON.Color3(0.79, 0.13, 0.13);\n    mat.alpha = 0.5;\n\n    let box = BABYLON.MeshBuilder.CreateBox(\"box\", options, scene);\n    box.material = mat;\n    box.position.x = 3;\n    box.position.y = 4;\n    box.position.z = 5;\n\n    let p1;\n    let p2;\n    let t1;\n    let t2;\n    let hermite;\n\n    var makeTextPlane = function (text, color, size) {\n        var dynamicTexture = new BABYLON.DynamicTexture(\"DynamicTexture\", { width: 890, height: 256 }, scene, true);\n        dynamicTexture.hasAlpha = true;\n        dynamicTexture.drawText(text, 0, 40, \"bold 44px monospace\", color, \"transparent\", true);\n        var plane = BABYLON.Mesh.CreatePlane(\"TextPlane\", size, scene, true);\n        plane.material = new BABYLON.StandardMaterial(\"TextPlaneMaterial\", scene);\n        plane.material.backFaceCulling = false;\n        plane.material.specularColor = new BABYLON.Color3(0, 0, 0);\n        plane.material.diffuseTexture = dynamicTexture;\n        return plane;\n        /*\n    \n            var ground = BABYLON.MeshBuilder.CreatePlane(\"ground1\", { width: 300, height: 100, subdivisions: 25 }, scene);\n    \n            var textureGround = new BABYLON.DynamicTexture(\"dynamic texture\", { width: 512, height: 256 }, scene);\n            textureGround.hasAlpha = true;\n            //var textureContext = textureGround.getContext();\n    \n            var materialGround = new BABYLON.StandardMaterial(\"Mat\", scene);\n            materialGround.diffuseTexture = textureGround;\n            materialGround.color = new BABYLON.Color3(1, 1, 1, 0)\n            ground.material = materialGround;\n       ground.material.backFaceCulling = false;\n            //Add text to dynamic texture\n            var font = \"bold 22px monospace\";\n            textureGround.drawText(text, 5, 135, font, color, \"white\", true, true);\n            return ground;        \n            */\n    };\n\n    {{{ payload }}}\n\n\n    var showAxis = function (size) {\n        var axisX = BABYLON.Mesh.CreateLines(\"axisX\", [\n            BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),\n            new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)\n        ], scene);\n        axisX.color = new BABYLON.Color3(1, 0, 0);\n        var xChar = makeTextPlane(\"X\", \"red\", size / 10);\n        xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);\n        var axisY = BABYLON.Mesh.CreateLines(\"axisY\", [\n            BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),\n            new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)\n        ], scene);\n        axisY.color = new BABYLON.Color3(0, 1, 0);\n        var yChar = makeTextPlane(\"Y\", \"green\", size / 10);\n        yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);\n        var axisZ = BABYLON.Mesh.CreateLines(\"axisZ\", [\n            BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),\n            new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)\n        ], scene);\n        axisZ.color = new BABYLON.Color3(0, 0, 1);\n        var zChar = makeTextPlane(\"Z\", \"blue\", size / 10);\n        zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);\n    };\n\n    showAxis(30);\n\n    return scene;    \n}","output":"str","x":1645.166748046875,"y":424.91668701171875,"wires":[["38b74d0d64f8aa50"]]},{"id":"38b74d0d64f8aa50","type":"ClientCode","z":"5f0c36ed4bd03058","name":"Copy to pasteboard","clientcode":"if (RED.clipboard.copyText(msg.payload) ) {\n    RED.notify(\"Babylon code copied to pasteboard.\", \"success\");\n} else {\n    RED.notify(\"ERORORORRRRO - check browser console.\", \"error\");\n}\n","format":"javascript","x":1876.105493632129,"y":429.96356201171875,"wires":[[]]},{"id":"efd6728cc65ccfc8","type":"http response","z":"5f0c36ed4bd03058","name":"","statusCode":"","headers":{},"x":1560.834716796875,"y":669.2535400390625,"wires":[]},{"id":"9f6ee13a0817687d","type":"function","z":"5f0c36ed4bd03058","name":"payload length becomes ...","func":"msg.payload = msg.payload.length\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[],"x":1324.33349609375,"y":358.5,"wires":[["e84b72656fe46c3e"]]},{"id":"e84b72656fe46c3e","type":"debug","z":"5f0c36ed4bd03058","name":"... node count","active":true,"tosidebar":false,"console":false,"tostatus":true,"complete":"payload","targetType":"msg","statusVal":"payload","statusType":"auto","x":1626.2017822265625,"y":361.8500061035156,"wires":[]},{"id":"42a1067b47e32f0b","type":"http in","z":"5f0c36ed4bd03058","name":"","url":"/3dflows/:flid/data","method":"get","upload":false,"swaggerDoc":"","x":247,"y":1412.640625,"wires":[["f4a532b31106c966"]]},{"id":"f4a532b31106c966","type":"GetFlows","z":"5f0c36ed4bd03058","name":"","flowVersion":"v1","useAuthentication":true,"apiUsername":"admin","apiUsernameType":"cred","apiPassword":"admin","apiPasswordType":"cred","x":683.3358764648438,"y":1423.1033935546875,"wires":[["424bbc1dd35916bf"]]},{"id":"424bbc1dd35916bf","type":"json","z":"5f0c36ed4bd03058","name":"","property":"payload","action":"obj","pretty":false,"x":963.816100417291,"y":1376.2973902172894,"wires":[["6b9ae05fbdd6d4e2"]]},{"id":"6b9ae05fbdd6d4e2","type":"function","z":"5f0c36ed4bd03058","name":"filter out requested flow","func":"msg.flid = msg.req.params.flid || path.dirname(node.path);\n\nif ( msg.flid != \"all\") {\n    var flids = msg.flid.split(\",\")\n\n    msg.payload = msg.payload.filter(function (obj) {\n        return (flids.indexOf(obj.id) > -1 || flids.indexOf(obj.z) > -1)\n    });\n}\n\nreturn msg;\n","outputs":1,"noerr":0,"initialize":"","finalize":"","libs":[{"var":"path","module":"path"}],"x":1274.1889189464093,"y":1411.5886673522014,"wires":[["efd6728cc65ccfc8"]]},{"id":"0f419226f5534b16","type":"http in","z":"5f0c36ed4bd03058","name":"","url":"/3dflows/:flid","method":"get","upload":false,"swaggerDoc":"","x":255,"y":1350.25,"wires":[["f262645b293839e4"]]},{"id":"d8156133774dd0a9","type":"template","z":"5f0c36ed4bd03058","name":"html template","field":"payload","fieldType":"msg","format":"handlebars","syntax":"mustache","template":"<!DOCTYPE html>\n<html xmlns=\"http://www.w3.org/1999/xhtml\">\n\n\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n    <title>Flows In 3D</title>\n\n    <style>\n        html,\n        body {\n            overflow: hidden;\n            width: 100%;\n            height: 100%;\n            margin: 0;\n            padding: 0;\n        }\n\n        #renderCanvas {\n            width: 100%;\n            height: 100%;\n            touch-action: none;\n        }\n        #fps {\n                opacity: 0.5;\n                position: absolute;\n                background-color: black;\n                border: 0px;\n                text-align: center;\n                font-size: 16px;\n                color: white;\n                top: 15px;\n                right: 10px;\n                width: 60px;\n                height: 20px;\n                visibility: hidden;\n            }        \n    </style>\n\n        <!-- Babylon.js \n            See https://doc.babylonjs.com/setup/frameworkPackages/frameworkVers\n            >>>\n            >>> WARNING: The CDN should not be used in production environments. Please use self-hosting for production.\n            >>>\n        -->\n        <script src=\"https://cdn.babylonjs.com/babylon.js\"></script>\n        <script src=\"https://cdn.babylonjs.com/gui/babylon.gui.min.js\"></script>\n        <script src=\"https://code.jquery.com/pep/0.4.3/pep.js\"></script>\n        \n         <script src=\"https://cdn.openmindmap.org/embed/flowviewer.min.js\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\n         <link rel=\"stylesheet\" href=\"https://cdn.openmindmap.org/embed/flowviewer.css\"/>\n         <script src=\"https://cdn.openmindmap.org/embed/jquery-3.7.0.min.js\" crossorigin=\"anonymous\" referrerpolicy=\"no-referrer\"></script>\n</head>\n\n<body>\n    <canvas id=\"renderCanvas\" touch-action=\"none\"></canvas>\n    <script>\n\nBABYLON.DefaultLoadingScreen.prototype.displayLoadingUI = function () {\n    if (document.getElementById(\"customLoadingScreenDiv\")) {\n        // Do not add a loading screen if there is already one\n        document.getElementById(\"customLoadingScreenDiv\").style.display = \"initial\";\n        return;\n    }\n    this._loadingDiv = document.createElement(\"div\");\n    this._loadingDiv.id = \"customLoadingScreenDiv\";\n    this._loadingDiv.innerHTML = \"Flow is loading ... <img src='https://cdn.openmindmap.org/content/1690311564501_loader.svg'/>\";\n    var customLoadingScreenCss = document.createElement('style');\n    customLoadingScreenCss.type = 'text/css';\n    customLoadingScreenCss.innerHTML = `\n    #customLoadingScreenDiv{\n        background-color: #BB464Bcc;\n        color: white;\n        font-size:50px;\n        text-align:center;\n        padding-top: 20%;\n    }\n    `;\n    document.getElementsByTagName('head')[0].appendChild(customLoadingScreenCss);\n    this._resizeLoadingUI();\n    window.addEventListener(\"resize\", this._resizeLoadingUI);\n    document.body.appendChild(this._loadingDiv);\n};\n\nBABYLON.DefaultLoadingScreen.prototype.hideLoadingUI = function(){\n    document.getElementById(\"customLoadingScreenDiv\").style.display = \"none\";\n}\n\n\n        {{{renderScene}}}\n\n        var canvas = document.getElementById(\"renderCanvas\");\n\n        var startRenderLoop = function (engine, canvas) {\n            engine.runRenderLoop(function () {\n                if (sceneToRender && sceneToRender.activeCamera) {\n                    sceneToRender.render();\n                }\n            });\n        }\n\n        var engine = null;\n        var scene = null;\n        var sceneToRender = null;\n        \n        var createDefaultEngine = function() { \n            return new BABYLON.Engine(canvas, true, { \n                preserveDrawingBuffer: true, \n                stencil: true,  \n                disableWebGL2Support: false\n            }); \n        };\n\n        // Resize\n        window.addEventListener(\"resize\", function () {\n            engine.resize();\n        });\n\n        var asyncEngineCreation = function() {\n           try {\n                    return createDefaultEngine();\n            } catch(e) {\n                    console.log(\"the available createEngine function failed. Creating the default engine instead\");\n                    return createDefaultEngine();\n            }\n        }\n\n        window.engine = asyncEngineCreation();\n        if (!engine) throw 'engine should not be null.';\n        engine.displayLoadingUI();\n\n        $.get(\"/3dflows/{{ req.params.flid }}/data\", (data,status) => {\n            if ( status != \"success\" ){\n             alert( 'failed to load flow data')\n             return\n            }\n            window.scene = renderScene( data )\n            scene = window.scene\n\n            console.log( scene.activeCamera )\n            inputHandler(scene); // - this is moving stuff in the scene.\n            sceneToRender = window.scene;\n            startRenderLoop(engine, canvas);\n        })\n\n\n    </script>\n\n<script>\n// reload the page on deploy, makes editing simpler. Is activated with a reload checkbox in the BlogPageInfo node.\nvar socket = undefined;\nvar socketUrl = undefined;\n\nfunction sendHome(msg, obj) {\n    try {\n        socket.send( JSON.stringify({\n            msg: msg,\n            obj: obj\n        }))\n    } catch ( ex ) {\n        console.error( \"sending on socket\", ex)\n        /* ignore exception */\n    }\n\n}\n\nfunction initSocket() {\n    if ( !socketUrl ) {\n        var loc = window.location, new_uri;\n        if (loc.protocol === \"https:\") {\n            new_uri = \"wss:\";\n        } else {\n            new_uri = \"ws:\";\n        }\n        new_uri += \"//\" + loc.host + \"/3dflows/ws\";\n        socketUrl = new_uri;\n    }\n  // Connection opened\n  socket = new WebSocket(socketUrl);\n\n  socket.onclose = function() {\n    initSocket();\n  };\n\n  // Listen for messages\n  socket.addEventListener(\"message\", (event) => {\n    if ( event.data == \"reload\") {\n      window.location.reload();\n    } else {\n        try {\n            var data = JSON.parse(event.data)\n            if ( data.action == \"moved\") {\n                var nde = data.node;\n                var obj = scene.getMeshByName(nde.id)\n                if ( obj ) {\n                    transformTo3DCoords(nde,zValues)\n\n                    if ( nodeIdtoNode[nde.id] ) {\n                        nodeIdtoNode[nde.id] = { \n                            ...nde,\n                            wires: nodeIdtoNode[nde.id].wires\n                        }\n                        nde = nodeIdtoNode[nde.id];\n                    }\n\n                    obj.position.x  = nde.x;\n                    obj.position.y  = nde.y;\n                    obj.position.z  = nde.z;\n\n                    for ( var xidx = 0 ; xidx < (nde.wires || []).length ; xidx ++ ) {\n                        for ( var yidx = 0 ; yidx < nde.wires[xidx].length ; yidx++ ) {\n                            var otherNode = nodeIdtoNode[nde.wires[xidx][yidx]]\n                            if ( otherNode ) { connectNodes(nde, otherNode)}\n                        }\n                    }\n                    \n                    Object.values(nodeIdtoNode).forEach( srcNde => {\n                        for ( var xidx = 0 ; xidx < (srcNde.wires || []).length ; xidx++ ) {\n                            for ( var yidx = 0 ; yidx < srcNde.wires[xidx].length ; yidx++ ) {\n                                if ( nde.id == srcNde.wires[xidx][yidx] ) {\n                                    connectNodes(srcNde, nde)\n                                }\n                            }\n                        }\n                    })\n                }\n            }\n        } catch (e){\n            console.log(\"NOT DOT\", event.data)\n        }\n    }\n  });\n};\n\ndocument.addEventListener(\"DOMContentLoaded\", initSocket );\n</script>\n\n</body>\n\n</html>\n","output":"str","x":1297.082275390625,"y":666.4097290039062,"wires":[["efd6728cc65ccfc8"]]},{"id":"1292a8972d3cb0e7","type":"template","z":"5f0c36ed4bd03058","name":"renderSceneAxis","field":"renderSceneAxis","fieldType":"msg","format":"javascript","syntax":"mustache","template":"{{{ renderSceneNodes }}}\n\n    var makeTextPlane = function (text, color, size) {\n        var dynamicTexture = new BABYLON.DynamicTexture(\"DynamicTexture\", { width: 890, height: 256 }, scene, true);\n        dynamicTexture.hasAlpha = true;\n        dynamicTexture.drawText(text, 0, 40, \"bold 44px monospace\", color, \"transparent\", true);\n        var plane = BABYLON.Mesh.CreatePlane(\"TextPlane\", size, scene, true);\n        plane.material = new BABYLON.StandardMaterial(\"TextPlaneMaterial\", scene);\n        plane.material.backFaceCulling = false;\n        plane.material.specularColor = new BABYLON.Color3(0, 0, 0);\n        plane.material.diffuseTexture = dynamicTexture;\n        return plane;\n    };\n\n    var showAxis = function (size) {\n        var axisX = BABYLON.Mesh.CreateLines(\"axisX\", [\n            BABYLON.Vector3.Zero(), new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, 0.05 * size, 0),\n            new BABYLON.Vector3(size, 0, 0), new BABYLON.Vector3(size * 0.95, -0.05 * size, 0)\n        ], scene);\n        axisX.color = new BABYLON.Color3(1, 0, 0);\n        var xChar = makeTextPlane(\"X\", \"red\", size / 10);\n        xChar.position = new BABYLON.Vector3(0.9 * size, -0.05 * size, 0);\n        var axisY = BABYLON.Mesh.CreateLines(\"axisY\", [\n            BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(-0.05 * size, size * 0.95, 0),\n            new BABYLON.Vector3(0, size, 0), new BABYLON.Vector3(0.05 * size, size * 0.95, 0)\n        ], scene);\n        axisY.color = new BABYLON.Color3(0, 1, 0);\n        var yChar = makeTextPlane(\"Y\", \"green\", size / 10);\n        yChar.position = new BABYLON.Vector3(0, 0.9 * size, -0.05 * size);\n        var axisZ = BABYLON.Mesh.CreateLines(\"axisZ\", [\n            BABYLON.Vector3.Zero(), new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, -0.05 * size, size * 0.95),\n            new BABYLON.Vector3(0, 0, size), new BABYLON.Vector3(0, 0.05 * size, size * 0.95)\n        ], scene);\n        axisZ.color = new BABYLON.Color3(0, 0, 1);\n        var zChar = makeTextPlane(\"Z\", \"blue\", size / 10);\n        zChar.position = new BABYLON.Vector3(0, 0.05 * size, 0.9 * size);\n    };\n\n","output":"str","x":888.954833984375,"y":937,"wires":[["a81eb6e36b98143d"]]},{"id":"b4ea0e0d782d1bdb","type":"UglifyJS","z":"5f0c36ed4bd03058","name":"","config":"{\"parse\":{},\"compress\":{},\"mangle\":{\"reserved\":[\"$\",\"export\",\"require\"]},\"output\":null,\"sourceMap\":null,\"nameCache\":null,\"toplevel\":false,\"warnings\":false}","configType":"json","property":"renderScene","propertyType":"msg","x":1157.2360098163188,"y":754.5116174917109,"wires":[["d8156133774dd0a9"]]},{"id":"d3789f2a3ae3566e","type":"catch","z":"5f0c36ed4bd03058","name":"","scope":null,"uncaught":false,"x":223,"y":1286,"wires":[["b6632ef77c8a0735"]]},{"id":"9d1a759fe0ffbc4c","type":"debug","z":"5f0c36ed4bd03058","name":"debug 65","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":418,"y":337,"wires":[]},{"id":"418831d8be330b70","type":"template","z":"5f0c36ed4bd03058","name":"renderSceneNodes","field":"renderSceneNodes","fieldType":"msg","format":"javascript","syntax":"mustache","template":"// @ts-ignore\n{{{ renderSceneCamera }}}\n\nlet nodeMaterials = {};\nlet redColor = new BABYLON.Color4(1, 0.07, 0.07, 0.97);\n\nconst options = {\n    wrap: false,\n    width: 3,\n    updatable: true,\n    faceColors: [\n        new BABYLON.Color4(0.81, 0.08, 0.46, 0.3),\n        new BABYLON.Color4(0.9, 0.08, 0.55, 0.84),\n        new BABYLON.Color4(0.91, 0.57, 0.07),\n        new BABYLON.Color4(0.09, 0.16, 0.77, 0.73),\n        new BABYLON.Color4(0.11, 1, 0.23, 0.77),\n        new BABYLON.Color4(0.81, 0.15, 0.1, 0.3),\n    ]\n};\n\n// for each flow (i.e. `z` value), compute a position in 3D space.\n// Specifically the flows are layered in the z-axis\nnodes.forEach((nd) => {\n    if (nd.z) {\n        zValues[nd.z] = zValues[nd.z] || (\n            Math.max.apply(Math, Object.values(zValues).concat([0])) + 200\n        )\n    }\n})\n\nif (Object.keys(zValues).length == 1) {\n    zValues[Object.keys(zValues)[0]] = 0\n}\n\nnodes.forEach((nd) => {\n    if (nd && nd.x && nd.y) {\n        transformTo3DCoords(nd, zValues)\n\n        var clr = clrByType[nd.type] || clrByType[\"_default\"];\n        var mth = (clr.fill || \"\").match(/rgb\\(([^,]+),([^,]+),([^,]+)\\)/)\n        if (mth) {\n            clr = \"#\" + parseInt(mth[1]).toString(16).padStart(2, \"0\") + parseInt(mth[2]).toString(16).padStart(2, \"0\") + parseInt(mth[3]).toString(16).padStart(2, \"0\")\n        } else {\n            mth = (clr.fill || \"\").match(/^#(.)(.)(.)$/)\n            if (mth) {\n                clr = \"#\" + mth[1] + mth[1] + mth[2] + mth[2] + mth[3] + mth[3]\n            } else {\n                clr = clr.fill;\n            }\n        }\n\n        clr = new BABYLON.Color4.FromHexString(clr);\n\n        box = createSoftBox(nd.id, {\n            ...options,\n            width: nd.width / 2, // softbox has a strange relationship to width values ... it doubles them!\n            height: nd.height || 20,\n            depth: nd.depth || 30,\n            radius: 8,\n            arcSegments: 10,\n            stretch: false,\n        }, scene);\n\n\n        if ( !nodeMaterials[nd.type] ) {\n            var dynamicTexture1 = new BABYLON.DynamicTexture(\"DT\"+nd.type, { width: 890, height: 123 }, scene);\n            dynamicTexture1.hasAlpha = true;\n            var textureContext = dynamicTexture1.getContext();\n            textureContext.fillStyle = clr.toHexString();\n            textureContext.fillRect(0,0,890,123);\n            dynamicTexture1.update();\n\n            mat = new BABYLON.StandardMaterial(nd.t + nd.id, scene);\n            mat.diffuseColor = clr//.toHexString()\n            mat.specularColor = clr//.toHexString()\n            mat.emissiveColor = clr//.toHexString()\n            mat.diffuseTexture = dynamicTexture1;\n            mat.alpha = 0.95;\n            nodeMaterials[nd.type] = mat\n        }\n\n        if ( nd.type != \"junction\" && nd.t != \"\") {\n            var plane = BABYLON.MeshBuilder.CreatePlane(\"plane\", { width: nd.width, height: 20 }, scene);\n            plane.parent = box;\n    //            plane.position.y = 0;\n\n            /* Generate the text for a node */\n\n            var dynamicTexture = new BABYLON.DynamicTexture(\"DText\"+nd.id, { width: 890, height: 123 }, scene);\n            dynamicTexture.hasAlpha = true;\n            dynamicTexture.drawText(nd.t, 10, 40, \"bold 32px monospace\", \"red\", \"transparent\", true);\n\n            plane.material = new BABYLON.StandardMaterial(\"Mat\"+nd.id, scene);\n            const material = plane.material;\n            material.emissiveTexture = dynamicTexture;\n            material.opacityTexture = dynamicTexture;\n\n            material.diffuseColor = redColor;\n            material.specularColor = redColor;\n            material.emissiveColor = redColor;\n\n            material.emissiveTexture.wrapU = BABYLON.Constants.TEXTURE_WRAP_ADDRESSMODE;\n            material.opacityTexture.wrapU = BABYLON.Constants.TEXTURE_WRAP_ADDRESSMODE;\n\n            // This does scrolling text, nice feature but browsers don't really like it.\n            /* \n            scene.onBeforeRenderObservable.add(() => {\n                material.emissiveTexture.uOffset += 0.001;\n                material.opacityTexture.uOffset += 0.001;\n            });\n            */\n        }\n\n        box.material = nodeMaterials[nd.type]; \n        box.position.x = nd.x;\n        box.position.y = nd.y;\n        box.position.z = nd.z;\n\n        nodeIdtoNode[nd.id] = nd\n    }\n})\n\n\nnodes.forEach(nd => {\n    if (nd && nd.wires) {\n        for (var pCnt = 0; pCnt < nd.wires.length; pCnt++) {\n            for (var wCnt = 0; wCnt < nd.wires[pCnt].length; wCnt++) {\n                let otherNode = nodeIdtoNode[nd.wires[pCnt][wCnt]]\n                if (otherNode) {\n                    connectNodes(nd, otherNode)\n                }\n            }\n        }\n    }\n})\n\n","output":"str","x":800.076458344249,"y":995,"wires":[["1292a8972d3cb0e7"]]},{"id":"3c2c3fd05a736f13","type":"template","z":"5f0c36ed4bd03058","name":"renderSceneCamera","field":"renderSceneCamera","fieldType":"msg","format":"javascript","syntax":"mustache","template":"\n    /*\n        var camera = new BABYLON.UniversalCamera(\"MyCamera\", new BABYLON.Vector3(0, 1, 0), scene);\n        camera.minZ = 0.0001;\n        camera.attachControl(canvas, true);\n        camera.speed = 1;\n        camera.angularSpeed = 0.1;\n        camera.angle = Math.PI;\n        //camera.direction = new BABYLON.Vector3(Math.cos(camera.angle), 0, Math.sin(camera.angle));\n        camera.inputs.addMouseWheel();\n        camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;\n        const mouse = camera.inputs.attached.mouse;\n        camera.inputs.remove(mouse);\n        const touch = camera.inputs.attached.touch;\n        camera.inputs.remove(touch);\n        camera.inputs.add(new FreeCameraPointersInput());\n    */\n    var camera = new BABYLON.ArcRotateCamera('camera', Math.PI / 2, 0, 100, new BABYLON.Vector3(0, 0, 0), scene);\n\n\n    // camera.mode = BABYLON.Camera.ORTHOGRAPHIC_CAMERA;\n\n    var distance = 500;\n    var aspect = scene.getEngine().getRenderingCanvasClientRect().height / scene.getEngine().getRenderingCanvasClientRect().width;\n    camera.orthoLeft = -distance / 2;\n    camera.orthoRight = distance / 2;\n    camera.orthoBottom = camera.orthoLeft * aspect;\n    camera.orthoTop = camera.orthoRight * aspect;\n\n    // last param from this function is telling you which buton to use for panning, so no more need line 34\n    camera.attachControl(canvas, true, false, 0);\n    // you don't need to call 2 time same function. it is enough 1 time\n    // camera.attachControl(canvas, true, false);\n\n    // using this property you can choose which axis to be use for panning\n    camera.panningAxis = new BABYLON.Vector3(1, 1, 0);\n    camera.upperBetaLimit = Math.PI ;\n    camera.wheelPrecision = 0.1;\n    camera.panningSensibility = 1;\n    camera.inertia = 0.5;\n    camera.panningInertia = 0.5;\n    camera.speed = 2;\n\n    // never use variable with _ because they are private and can be changed durring development\n    // camera._panningMouseButton = 0; // change functionality from left to right mouse button\n    camera.angularSensibilityX = 500;\n    camera.angularSensibilityY = 500;\n\n    const mouse = camera.inputs.attached.mouse;\n    camera.inputs.remove(mouse);\n    const touch = camera.inputs.attached.touch;\n    camera.inputs.remove(touch);\n    camera.inputs.add(new FreeCameraPointersInput());\n    camera.position = new BABYLON.Vector3(-2500, 2500, -2500)\n\n    /*\n        var camera = new BABYLON.UniversalCamera(\"camera1\", new BABYLON.Vector3(0, 0, 0), scene, true);\n        //camera.setTarget(new BABYLON.Vector3(2500, 2500, 100));\n        // camera.attachControl(canvas, true);\n        //camera.inputs.attached[\"mousewheel\"].wheelPrecisionY = -1;\n        camera.useFramingBehavior = true;\n        camera.lowerRadiusLimit = null;\n    */\n    \n    var light1 = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(1, 1, 0), scene);\n    light1.intensity = 1;\n    light1.groundColor = new BABYLON.Color3(1, 1, 1);\n\n    var light2 = new BABYLON.PointLight(\"light2\", new BABYLON.Vector3(0, 1, -1), scene);\n    var light3 = new BABYLON.HemisphericLight(\"light1\", new BABYLON.Vector3(0, 1, 1), scene);\n    light2.intensity = 1;\n    light2.groundColor = new BABYLON.Color3(123, 1, 1);\n    \n    light3.intensity = 1;\n    light3.groundColor = new BABYLON.Color3(1, 1, 1);\n\n\n    let mat = new BABYLON.StandardMaterial(\"fubar\", scene);\n    mat.diffuseColor = new BABYLON.Color3(0.9, 1, 0)\n    mat.specularColor = new BABYLON.Color3(0.79, 0.13, 0.13);\n    mat.alpha = 0.5;\n\n    let box;\n    let p1;\n    let p2;\n    let t1;\n    let t2;\n    let hermite;\n\n\n\nvar dome = new BABYLON.PhotoDome(\n    \"testdome\",\n    \"https://cdn.openmindmap.org/content/1700484067973_dome.png\",\n    {\n        resolution: 32,\n        size: 15000\n    },\n    scene\n);\n\n//dome.infiniteDistance = true;\ndome.mesh.material.diffuseTexture.hasAlpha = true;\n\n//dome.mesh.material.diffuseTexture.hasAlpha = true;\ndome.mesh.material.useAlphaFromDiffuseTexture = true;\n\n// dome.scalingDeterminant = 0.75","output":"str","x":729.4746336744977,"y":1053,"wires":[["418831d8be330b70"]]},{"id":"a5a83d3d61101034","type":"template","z":"5f0c36ed4bd03058","name":"FreeCameraPointersInput","field":"FreeCameraPointersInput","fieldType":"msg","format":"javascript","syntax":"mustache","template":"class FreeCameraPointersInput extends BABYLON.BaseCameraPointersInput {\n    angularSensibility = 2000.0;\n\n    // Touch-based variables\n    singleFingerRotate = false;\n    touchMoveSensibility = 250.0;\n    touchAngularSensibility = 200000.0;\n    touchEnabled = true;\n\n    _offsetX = null;\n    _offsetY = null;\n    _previousPositionX = null;\n    _previousPositionY = null;\n    _touches = 0;\n\n    getClassName() {\n        return \"FreeCameraPointersInput\";\n    }\n\n    // We don't need to add the getSimpleName function as the base class\n    // already provides a value of \"pointers\".  If you want it to be something\n    // else though, feel free to implement it.\n\n    // getSimpleName(): string;\n\n    // While normally, you'd also have to add an attachControl and detachControl function\n    // when creating a custom input, this will already be handled by the base class.\n    // You can also override them if you want but they do a lot of the heavy lifting so\n    // be warned.\n\n    // attachControl(noPreventDefault?: boolean);\n    // detachControl();\n\n    /**\n     * checkInputs\n     * \n     * It should be noted that this class is optional in general custom input development.\n     * It will execute this function every frame.  We're using it here to update the camera \n     * position/rotation in the same way as the touch class it's based off of.  If you don't\n     * need to update something each frame, this function doesn't need to be overridden.\n     */\n    checkInputs() {\n        if (this.touchEnabled || this._offsetX === null || this._offsetY === null) {\n            return;\n        }\n        if (this._offsetX === 0 && this._offsetY === 0) {\n            return;\n        }\n\n        // For most camera types (except for any based off of ArcRotateCamera), positions\n        // and rotations are changed by modifying the cameraDirection and cameraRotation\n        // vectors.\n        const camera = this.camera;\n        camera.cameraRotation.y = this._offsetX / this.touchAngularSensibility;\n\n        const rotateCamera = (this.singleFingerRotate && this._touches === 1) || (!this.singleFingerRotate && this._touches > 1);\n\n        if (rotateCamera) {\n            camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;\n        } else {\n            const speed = camera._computeLocalCameraSpeed();\n            const direction = new BABYLON.Vector3(0, 0, this.touchMoveSensibility !== 0 ? (speed * this._offsetY) / this.touchMoveSensibility : 0);\n\n            BABYLON.Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);\n            camera.cameraDirection.addInPlace(BABYLON.Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));\n        }\n    }\n\n    /**\n     * onTouch\n     * \n     * This function is required.  This will handle all logic related to a single touch.\n     * This is called during a POINTERMOVE event.\n     */\n    onTouch(point, offsetX, offsetY) {\n        let directionAdjust = 1;\n        if (this.camera.getScene().useRightHandedSystem) {\n            directionAdjust *= -1;\n        }\n        if (this.camera.parent && this.camera.parent._getWorldMatrixDeterminant() < 0) {\n            directionAdjust *= -1;\n        }\n\n        this.camera.cameraRotation.y += directionAdjust * offsetX / this.angularSensibility;\n\n        // Since point holds the 'pointerType' from the firing event, we can access it here via 'type'\n        // offsetX/Y will be clientX/Y - the previously stored point's x/y\n        if (point.type === \"mouse\" || (point.type === \"touch\" && this.touchEnabled)) {\n            this.camera.cameraRotation.x += offsetY / this.angularSensibility;\n        }\n        else if (this._previousPositionX === null || this._previousPositionY === null) {\n            return;\n        }\n        else {\n            this._offsetX = point.x - this._previousPositionX;\n            this._offsetY = -(point.y - this._previousPositionY);\n        }\n    }\n\n    /**\n     * onMultiTouch\n     * \n     * This function is required.  This will handle all logic when there are multiple active touches.\n     * This is called during a POINTERMOVE event.\n     * \n     * pointA and B should never be null if this is called, unless you are manually calling this.\n     * \n     * The distances should also always have a value.\n     * \n     * The pan positions (which could be renamed as long as the data types are the same) may be \n     * null at the beginning or the end of a movement.\n     */\n    onMultiTouch(\n        pointA,\n        pointB,\n        previousPinchSquaredDistance,\n        pinchSquaredDistance,\n        previousMultiTouchPanPosition,\n        multiTouchPanPosition\n    ) {\n        if (!this.touchEnabled && multiTouchPanPosition) {\n            this._offsetX = multiTouchPanPosition.x - this._previousPositionX;\n            this._offsetY = -(multiTouchPanPosition.y - this._previousPositionY);\n        }\n    }\n\n    /**\n     * onButtonDown\n     * \n     * This function will trigger when a touch or button is pressed down.\n     */\n    onButtonDown(evt) {\n        if (evt.pointerType === \"touch\" && !this.touchEnabled) {\n            this._previousPositionX = evt.clientX;\n            this._previousPositionY = evt.clientY;\n            this._touches++;\n        }\n    }\n\n    /**\n     * onButtonUp\n     * \n     * This function will trigger when a touch or button is pressed up.\n     */\n    onButtonUp(evt) {\n        if (evt.pointerType === \"touch\" && !this.touchEnabled) {\n            this._previousPositionX = null;\n            this._previousPositionY = null;\n            this._offsetX = null;\n            this._offsetY = null;\n            this._touches -= this._touches > 0 ? 1 : 0;\n        }\n    }\n}\n\n\n","output":"str","x":636,"y":1111,"wires":[["3c2c3fd05a736f13"]]},{"id":"72156c5f0736fedb","type":"template","z":"5f0c36ed4bd03058","name":"renderSceneFunction","field":"renderScene","fieldType":"msg","format":"javascript","syntax":"mustache","template":"{{{ FunctConnectNodes }}}\n\n{{{ FreeCameraPointersInput }}}\n\n{{{ CreateSoftBox }}}\n\n{{{ FunctTransformsNodeCoordsto3d }}}\n\n{{{ InputHandler }}}\n\nlet nodeIdtoNode = {};\nlet zValues = {};\n\nfunction renderScene(nodes) {\n    var scene = new BABYLON.Scene(engine);\n    //scene.clearColor = new BABYLON.Color3(0xE5/0xff, 0xE5/0xff, 0xE5/0xff)\n    scene.clearColor = new BABYLON.Color3(0.77, 0.76, 0.83);;\n    window.scene = scene;\n    \n{{{ renderSceneAxis }}}\n\n    //showAxis(30);\n\n    engine.hideLoadingUI();\n\n    return scene;\n}\n\n","output":"str","x":1092.499755859375,"y":821,"wires":[["b4ea0e0d782d1bdb"]]},{"id":"f262645b293839e4","type":"template","z":"5f0c36ed4bd03058","name":"CreateSoftBox","field":"CreateSoftBox","fieldType":"msg","format":"javascript","syntax":"mustache","template":"function createSoftBox(name, opt, scene) {\n    var size = opt.size ?? 1\n    var height = opt.height ?? size / 2\n    var width = opt.width ?? size / 2\n    var depth = opt.depth ?? size / 2\n    var heightTop = opt.heightTop ?? height\n    var widthLeft = opt.widthLeft ?? width\n    var depthBack = opt.depthBack ?? depth\n    var heightBottom = opt.heightBottom ?? height\n    var widthRight = opt.widthRight ?? width\n    var depthFront = opt.depthFront ?? depth\n\n    var arcSegments = Math.max(opt.arcSegments ?? 1, 1)\n    var radius = Math.max(opt.radius ?? 0, 0)\n    var radiusX = Math.max(opt.radiusX ?? radius, 0)\n    var radiusY = Math.max(opt.radiusY ?? radius, 0)\n    var radiusZ = Math.max(opt.radiusZ ?? radius, 0)\n    var radiusXPos = Math.max(opt.radiusXPos ?? radiusX, 0)\n    var radiusYPos = Math.max(opt.radiusYPos ?? radiusY, 0)\n    var radiusZPos = Math.max(opt.radiusZPos ?? radiusZ, 0)\n    var radiusXNeg = Math.max(opt.radiusXNeg ?? radiusX, 0)\n    var radiusYNeg = Math.max(opt.radiusYNeg ?? radiusY, 0)\n    var radiusZNeg = Math.max(opt.radiusZNeg ?? radiusZ, 0)\n\n    var stretch = opt.stretch ?? false\n    var stretchX = opt.stretchX ?? stretch\n    var stretchY = opt.stretchY ?? stretch\n    var stretchZ = opt.stretchZ ?? stretch\n\n    var heightTopInner = Math.max(heightTop - radiusYPos, 0)\n    var widthLeftInner = Math.max(widthLeft - radiusXPos, 0)\n    var depthBackInner = Math.max(depthBack - radiusZPos, 0)\n\n    var heightBottomInner = Math.max(heightBottom - radiusYNeg, 0)\n    var widthRightInner = Math.max(widthRight - radiusXNeg, 0)\n    var depthFrontInner = Math.max(depthFront - radiusZNeg, 0)\n\n    var getArc = (\n        offset,\n        width,\n        height,\n        depth,\n        radiusX,\n        radiusY,\n        radiusZ,\n        innerInc,\n        outerInc,\n        stretchX,\n        stretchY,\n        stretchZ\n    ) => {\n        let x = stretchX\n            ? (Math.abs(width) + radiusX) *\n            Math.cos(offset + outerInc * arc) *\n            Math.cos(innerInc * arc)\n            : width +\n            radiusX * Math.cos(offset + outerInc * arc) * Math.cos(innerInc * arc)\n        let y = stretchY\n            ? (Math.abs(height) + radiusY) * Math.sin(innerInc * arc)\n            : height + radiusY * Math.sin(innerInc * arc)\n        let z = stretchZ\n            ? (Math.abs(depth) + radiusZ) *\n            Math.sin(offset + outerInc * arc) *\n            Math.cos(innerInc * arc)\n            : depth +\n            radiusZ * Math.sin(offset + outerInc * arc) * Math.cos(innerInc * arc)\n\n        var ret = new BABYLON.Vector3(x, y, z)\n\n        return ret\n    }\n\n    const paths = []\n    const arc = Math.PI / (2 * arcSegments)\n\n    const path = []\n\n    var addSegment = (\n        offset,\n        segments,\n        width,\n        heightTop,\n        heightBottom,\n        depth\n    ) => {\n        for (let t = 0; t <= segments; t++) {\n            var angle = Math.cos((Math.PI * t) / (arcSegments * 2))\n            //console.log(`t:${t}, angle: ${angle}`)\n\n            const path = []\n\n            //console.log(\"arcSegment\", arcSegments)\n\n            path.push(\n                getArc(\n                    offset,\n                    0,\n                    -heightBottom,\n                    0,\n                    radiusXPos,\n                    radiusYPos,\n                    radiusZPos,\n                    -arcSegments,\n                    t,\n                    stretchX,\n                    stretchY,\n                    stretchZ\n                )\n            )\n\n            for (let a = -arcSegments; a <= 0; a++) {\n                const height = a > 0 ? heightTop : -heightBottom\n                path.push(\n                    getArc(\n                        offset,\n                        width,\n                        height,\n                        depth,\n                        radiusXPos,\n                        radiusYPos,\n                        radiusZPos,\n                        a,\n                        t,\n                        stretchX,\n                        stretchY,\n                        stretchZ\n                    )\n                )\n            }\n\n            path.push(\n                getArc(\n                    offset,\n                    width,\n                    0,\n                    depth,\n                    radiusXPos,\n                    radiusYPos,\n                    radiusZPos,\n                    0,\n                    t,\n                    stretchX,\n                    stretchY,\n                    stretchZ\n                )\n            )\n\n            for (let a = 0; a <= arcSegments; a++) {\n                const height = a >= 0 ? heightTop : -heightBottom\n                path.push(\n                    getArc(\n                        offset,\n                        width,\n                        height,\n                        depth,\n                        radiusXPos,\n                        radiusYPos,\n                        radiusZPos,\n                        a,\n                        t,\n                        stretchX,\n                        stretchY,\n                        stretchZ\n                    )\n                )\n            }\n\n            path.push(\n                getArc(\n                    offset,\n                    0,\n                    heightTop,\n                    0,\n                    radiusXPos,\n                    radiusYPos,\n                    radiusZPos,\n                    arcSegments,\n                    t,\n                    stretchX,\n                    stretchY,\n                    stretchZ\n                )\n            )\n\n            paths.push(path)\n        }\n    }\n\n    //const width = angle > 0 ? widthp : -widthn;\n    //const depth = Math.floor(t / arcSegments!!) < 2 ? depthp : -depthn;\n\n    if (!stretch && widthLeftInner + widthRightInner > 0)\n        addSegment(0, 0, widthRightInner, heightTopInner, heightBottomInner, 0)\n    addSegment(\n        0,\n        arcSegments,\n        widthRightInner,\n        heightTopInner,\n        heightBottomInner,\n        depthBackInner\n    )\n\n    if (!stretch && depthBackInner + depthFrontInner > 0)\n        addSegment(\n            Math.PI / 2,\n            0,\n            0,\n            heightTopInner,\n            heightBottomInner,\n            depthBackInner\n        )\n    addSegment(\n        Math.PI / 2,\n        arcSegments,\n        -widthLeftInner,\n        heightTopInner,\n        heightBottomInner,\n        depthBackInner\n    )\n\n    if (!stretch && widthLeftInner + widthRightInner > 0)\n        addSegment(\n            Math.PI,\n            0,\n            -widthLeftInner,\n            heightTopInner,\n            heightBottomInner,\n            0\n        )\n    addSegment(\n        Math.PI,\n        arcSegments,\n        -widthLeftInner,\n        heightTopInner,\n        heightBottomInner,\n        -depthFrontInner\n    )\n\n    if (!stretch && depthBackInner + depthFrontInner > 0)\n        addSegment(\n            (3 * Math.PI) / 2,\n            0,\n            0,\n            heightTopInner,\n            heightBottomInner,\n            -depthFrontInner\n        )\n    addSegment(\n        (3 * Math.PI) / 2,\n        arcSegments,\n        widthRightInner,\n        heightTopInner,\n        heightBottomInner,\n        -depthFrontInner\n    )\n\n    //console.log(paths)\n\n    const ribbon = BABYLON.MeshBuilder.CreateRibbon(\n        name,\n        {\n            pathArray: paths,\n            sideOrientation: BABYLON.Mesh.FRONTSIDE,\n            closeArray: true,\n            invertUV: true\n        },\n        scene\n    )\n\n    return ribbon\n}\n","output":"str","x":465,"y":1285,"wires":[["ce8aae7bc6c2e656"]]},{"id":"8395478f3fc897f3","type":"websocket in","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"","server":"b0271a128bbbe506","client":"","x":327,"y":1698,"wires":[["c658b245f674c7b1"]]},{"id":"e0e7f140354ff1db","type":"websocket out","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"","server":"b0271a128bbbe506","client":"","x":1535.4542236328125,"y":1858.2646484375,"wires":[]},{"id":"3c3b43ba91bfcd40","type":"inject","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"reload open pages","props":[{"p":"payload"}],"repeat":"","crontab":"","once":false,"onceDelay":"0.8","topic":"","payload":"reload","payloadType":"str","x":936.5,"y":1972,"wires":[["e0e7f140354ff1db"]]},{"id":"5932a19455e61097","type":"ClientCode","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"[Events] On Deploy","clientcode":"// Ensure that the event listener is only \n// set once.\n\nvar lstnName = \"deployListener\" + nodeid;\n\nif (payload == \"setup\") {\n    if (!window[lstnName]) {\n        window[lstnName] = (e) => {\n            node.send({\n                payload: \"deploy:done\"\n            })\n        }\n        RED.events.on('deploy', window[lstnName]);\n\n        RED.notify(\"Deploy listener setup\", {\n            type: \"success\",\n            timeout: 2500,\n            id: nodeid\n        })\n    } else {\n        RED.notify(\"Deploy listener already set up\", {\n            type: \"warning\",\n            timeout: 2500,\n            id: nodeid\n        })\n    }\n}\n\n// Remove listener if required\n\nif (payload == \"remove\") {\n    if (window[lstnName]) {\n        RED.events.off('deploy', window[lstnName]);\n        window[lstnName] = undefined;\n        \n        RED.notify(\"Deploy listener removed\", {\n            type: \"success\",\n            timeout: 2500,\n            id: nodeid\n        })        \n    } else {\n        RED.notify(\"No Deploy listener defined\", {\n            type: \"warning\",\n            timeout: 2500,\n            id: nodeid\n        })        \n    }\n}","format":"javascript","x":653.5,"y":1909,"wires":[["342f5b551d4717a9"]]},{"id":"463c51a486c3925c","type":"inject","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"setup event listener","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"setup","payloadType":"str","x":360.5,"y":1972,"wires":[["5932a19455e61097","fc66b2501a7e22e3"]]},{"id":"342f5b551d4717a9","type":"change","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"","rules":[{"t":"set","p":"payload","pt":"msg","to":"reload","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":919.3752813805436,"y":1863.933472178849,"wires":[["e0e7f140354ff1db"]]},{"id":"fc66b2501a7e22e3","type":"ClientCode","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"[Events] On Workspace dirty","clientcode":"// Ensure that the event listener is only \n// set once.\n\nvar lstnName = \"workspaceDirtyListener\" + nodeid;\n\nif (payload == \"setup\") {\n    if (!window[lstnName]) {\n        window[lstnName] = (e) => {\n            node.send({\n                payload: \"workspace:dirty\"\n            })\n        }\n        RED.events.on('workspace:dirty', window[lstnName]);\n\n        RED.notify(\"Workspace listener setup\", {\n            type: \"success\",\n            timeout: 2500,\n            id: nodeid\n        })\n    }\n}\n\n// Remove listener if required\n\nif (payload == \"remove\") {\n    if (window[lstnName]) {\n        RED.events.off('workspace:dirty', window[lstnName]);\n        window[lstnName] = undefined;\n        \n        RED.notify(\"Workspace listener removed\", {\n            type: \"success\",\n            timeout: 2500,\n            id: nodeid\n        })        \n    }\n}","format":"javascript","x":653.5,"y":2035,"wires":[["e8db65f9438f2b21"]]},{"id":"e8db65f9438f2b21","type":"ClientCode","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"All moved nodes","clientcode":"RED.nodes.eachNode( nde => {\n    if ( nde.moved ) {\n        node.send({payload: {\n            action: \"moved\",\n            node: { ...nde }\n        }})\n    }\n})","format":"javascript","x":936.5,"y":2035,"wires":[["e0e7f140354ff1db"]]},{"id":"7291a2ae1a4b3dfb","type":"template","z":"5f0c36ed4bd03058","name":"FunctConnectNodes","field":"FunctConnectNodes","fieldType":"msg","format":"javascript","syntax":"mustache","template":"function connectNodes(nd, otherNode) {\n    /* generate link path magically this comes from renderFlow library */\n    var svgPathStr = generateLinkPath(nd.ports.output.x, nd.ports.output.y, otherNode.ports.input.x, otherNode.ports.input.y, 1)\n    /* Check this for SVG Path specifications and its meanings --> https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths */\n    var pts = svgPathStr.split(/\\s+/).map(d => { return parseFloat(d) })\n    var pts3d = null;\n    var idstr = nd.id + \"-\" + otherNode.id\n\n    if (svgPathStr.indexOf('S') < 0) {\n        /* no 'S', simply Bezier with two control points */\n        const bezier3 = BABYLON.Curve3.CreateCubicBezier(\n            new BABYLON.Vector3(pts[1], pts[2], nd.z),\n            new BABYLON.Vector3(pts[4], pts[5], nd.z),\n            new BABYLON.Vector3(pts[6], pts[7], otherNode.z),\n            new BABYLON.Vector3(pts[8], pts[9], otherNode.z),\n            40)\n        pts3d = bezier3.getPoints();\n    } else {\n        /* argh, we have sub-curves since there is S, in fact three S */\n\n        const bezier1 = BABYLON.Curve3.CreateCubicBezier(\n            new BABYLON.Vector3(pts[1], pts[2], nd.z),\n            new BABYLON.Vector3(pts[4], pts[5], nd.z),\n            new BABYLON.Vector3(pts[6], pts[7], nd.z),\n            new BABYLON.Vector3(pts[8], pts[9], nd.z),\n            40)\n\n        const bezier2 = BABYLON.Curve3.CreateQuadraticBezier(\n            new BABYLON.Vector3(pts[8], pts[9], nd.z),\n            new BABYLON.Vector3(pts[11], pts[12], nd.z),\n            new BABYLON.Vector3(pts[13], pts[14], nd.z),\n            40)\n\n        const bezier3 = BABYLON.Curve3.CreateQuadraticBezier(\n            new BABYLON.Vector3(pts[13], pts[14], nd.z),\n            new BABYLON.Vector3(pts[16], pts[17], nd.z),\n            new BABYLON.Vector3(pts[18], pts[19], nd.z),\n            40)\n\n        const bezier4 = BABYLON.Curve3.CreateQuadraticBezier(\n            new BABYLON.Vector3(pts[18], pts[19], nd.z),\n            new BABYLON.Vector3(pts[21], pts[22], nd.z),\n            new BABYLON.Vector3(pts[23], pts[24], nd.z),\n            40);\n\n\n        pts3d = bezier1.getPoints().concat(bezier2.getPoints()).concat(bezier3.getPoints()).concat(bezier4.getPoints())\n    }\n\n    var scene = window.scene;\n    var existingTube = scene.getMeshByName(\"tube\" + idstr)\n    if ( existingTube ) {\n        existingTube.dispose()\n    }\n\n    const tube = BABYLON.MeshBuilder.CreateTube(\"tube\" + idstr, { path: pts3d, radius: 3, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true }, scene);\n\n    if (!window.tubeMaterial) {\n        var clr = new BABYLON.Color3(0.6, 0.58, 0.58);\n\n        var dynamicTexture1 = new BABYLON.DynamicTexture(\"tubeDT\", { width: 890, height: 123 }, scene);\n        dynamicTexture1.hasAlpha = true;\n\n        var textureContext = dynamicTexture1.getContext();\n        textureContext.fillStyle = clr.toHexString();\n        textureContext.fillRect(0, 0, 890, 123);\n\n        dynamicTexture1.update();\n\n        var mat = new BABYLON.StandardMaterial(\"tubemat\", scene);\n        mat.diffuseColor = clr//.toHexString()\n        mat.specularColor = clr//.toHexString()\n        mat.emissiveColor = clr//.toHexString()\n        mat.diffuseTexture = dynamicTexture1;\n        mat.alpha = 0.60;\n\n        window.tubeMaterial = mat;\n    }\n    \n    tube.material = window.tubeMaterial;\n}","output":"str","x":572,"y":1169,"wires":[["a5a83d3d61101034"]]},{"id":"ce8aae7bc6c2e656","type":"template","z":"5f0c36ed4bd03058","name":"FunctTransformsNodeCoordsto3d","field":"FunctTransformsNodeCoordsto3d","fieldType":"msg","format":"javascript","syntax":"mustache","template":"function transformTo3DCoords(nd,zValues) {\n    nd.l = Math.min(Math.max(100, (nd.name || nd.info || nd.type || \"\").length * 7), 800)\n\n    nd.x = (nd.x - 2500) * 1\n    nd.y = (nd.y - 2500) * -1\n    nd.zLayer = nd.z;\n    nd.z = zValues[nd.z];\n\n    nd.height = 18;\n    nd.width = nd.l\n\n    if (nd.type == \"junction\") {\n        nd.width = 2;\n        nd.height = 2;\n        nd.depth = 2;\n    }\n\n    nd.ports = {\n        output: {\n            x: nd.x + nd.width / 2,\n            y: nd.y,\n        },\n        input: {\n            x: nd.x - nd.width / 2,\n            y: nd.y\n        }\n    }\n\n    nd.t = (nd.name || nd.info || nd.type || \"\").replaceAll('\"', \"\\\\\\\"\").replaceAll(\"\\n\", \"\\\\n\")\n}\n\nfunction transformCoordsTo2D(pos) {\n    return {\n        _x: (pos._x + 2500),\n        _y: (pos._y * -1) + 2500\n    }\n}\n","output":"str","x":513,"y":1227,"wires":[["7291a2ae1a4b3dfb"]]},{"id":"a81eb6e36b98143d","type":"template","z":"5f0c36ed4bd03058","name":"InputHandler","field":"InputHandler","fieldType":"msg","format":"javascript","syntax":"mustache","template":"function inputHandler(scene) {\n\n  var controlIsDown = false;\n\n  scene.onKeyboardObservable.add((kbInfo) => {\n    switch (kbInfo.type) {\n      case BABYLON.KeyboardEventTypes.KEYDOWN:\n        console.log(\"KEY DOWN: \", kbInfo.event.code);\n\n        controlIsDown = kbInfo.event.ctrlKey || kbInfo.event.metaKey\n        if (controlIsDown && kbInfo.event.key == \"z\") {\n          sendHome(\"undo\",{})\n        }\n        if (controlIsDown && kbInfo.event.key == \"y\") {\n          sendHome(\"redo\", {})\n        }\n        if (controlIsDown && kbInfo.event.key == \"d\") {\n          sendHome(\"deploy\", {})\n        }\n        break;\n        \n      case BABYLON.KeyboardEventTypes.KEYUP:\n        console.log(\"KEY UP: \", kbInfo.event.code);\n        controlIsDown = kbInfo.event.ctrlKey || kbInfo.event.metaKey\n        break;\n    }\n  });\n\n  var startingPoint;\n  var currentMesh;\n  var camera = scene.activeCamera\n  var canvas = document.getElementById(\"renderCanvas\");\n\n  var getGroundPosition = function () {\n    var pickinfo = scene.pick(scene.pointerX, scene.pointerY) //, function (mesh) { return mesh == ground; });\n    if (pickinfo.hit) {\n      return pickinfo.pickedPoint;\n    }\n\n    return null;\n  }\n\n  var pointerDown = function (mesh) {\n    currentMesh = mesh;\n    startingPoint = getGroundPosition();\n    if (startingPoint) { // we need to disconnect camera from canvas\n      setTimeout(function () {\n        camera.detachControl(canvas);\n      }, 0);\n    }\n  }\n\n  var pointerUp = function () {\n    if (startingPoint) {\n      camera.attachControl(canvas, true);\n      startingPoint = null;\n\n      if ( currentMesh ) {\n        sendHome(\"meshmoved\", {\n          id: currentMesh.name,\n          pos: transformCoordsTo2D(currentMesh.position)\n        })\n        currentMesh = null;\n      }\n      \n      return;\n    }\n  }\n\n  var pointerMove = function () {\n    if (!startingPoint) {\n      return;\n    }\n    var current = getGroundPosition();\n    if (!current) {\n      return;\n    }\n\n    var diff = current.subtract(startingPoint);\n\n    currentMesh.position.addInPlace(diff);\n\n    startingPoint = current;\n  }\n\n  scene.onPointerObservable.add((pointerInfo) => {\n    switch (pointerInfo.type) {\n      case BABYLON.PointerEventTypes.POINTERDOWN:\n        if (pointerInfo.pickInfo.hit /* && pointerInfo.pickInfo.pickedMesh != ground */) {\n          let pmesh = pointerInfo.pickInfo.pickedMesh;\n          if ( pmesh.name.match( /^[a-f0-9]{16}$/i)) {\n            pointerDown(pmesh)\n          }\n        }\n        console.log(\"POINTER DOWN\");\n        break;\n      case BABYLON.PointerEventTypes.POINTERUP:\n        pointerUp();\n        console.log(\"POINTER UP\");\n        break;\n      case BABYLON.PointerEventTypes.POINTERMOVE:\n        pointerMove();\n        console.log(\"POINTER MOVE\");\n        break;\n      case BABYLON.PointerEventTypes.POINTERWHEEL:\n        console.log(\"POINTER WHEEL\");\n        break;\n      case BABYLON.PointerEventTypes.POINTERPICK:\n        console.log(\"POINTER PICK\");\n        break;\n      case BABYLON.PointerEventTypes.POINTERTAP:\n        console.log(\"POINTER TAP\");\n        break;\n      case BABYLON.PointerEventTypes.POINTERDOUBLETAP:\n        console.log(\"POINTER DOUBLE-TAP\");\n        break;\n    }\n  });\n\n}","output":"str","x":980,"y":879,"wires":[["72156c5f0736fedb"]]},{"id":"c658b245f674c7b1","type":"json","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"","property":"payload","action":"obj","pretty":false,"x":565.2630615234375,"y":1696.3531494140625,"wires":[["a62f5d55793a72a8"]]},{"id":"a62f5d55793a72a8","type":"switch","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"","property":"payload.msg","propertyType":"msg","rules":[{"t":"eq","v":"meshmoved","vt":"str"},{"t":"eq","v":"redo","vt":"str"},{"t":"eq","v":"undo","vt":"str"},{"t":"eq","v":"deploy","vt":"str"}],"checkall":"true","repair":false,"outputs":4,"x":827.0336303710938,"y":1697.24755859375,"wires":[["eba6a680c523ca75"],["51d0a5ffe2d6a314"],["4a6bab7124c86673"],["bbf1ee13e84f420b"]]},{"id":"eba6a680c523ca75","type":"ClientCode","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"move nodes here","clientcode":"let nd = RED.nodes.node(msg.payload.obj.id)\nif (nd) {\n    var hist = {\n        moved: false,\n        n: nd,\n        ox: nd.x,\n        oy: nd.y\n    }\n    nd.x = msg.payload.obj.pos._x;\n    nd.y = msg.payload.obj.pos._y;\n\n    nd.dirty = true;\n    RED.nodes.dirty(true);\n\n    if (hist.ox != nd.x || hist.oy != nd.y) {\n        hist.moved = true\n        RED.history.push({ t: \"move\", nodes: [hist], dirty: true });\n\n        node.send({\n            payload: {\n                action: \"moved\",\n                node: { ...nd }\n            }\n        })\n    }    \n    RED.view.redraw();\n}\n","format":"javascript","x":1299.374267578125,"y":1701.996337890625,"wires":[["e0e7f140354ff1db"]]},{"id":"51d0a5ffe2d6a314","type":"ClientCode","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"redo","clientcode":"RED.actions.invoke(\"core:redo\")","format":"javascript","x":1099,"y":1726,"wires":[[]]},{"id":"4a6bab7124c86673","type":"ClientCode","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"undo","clientcode":"RED.actions.invoke(\"core:undo\")","format":"javascript","x":1091.3293192561014,"y":1765.2698461785521,"wires":[[]]},{"id":"bbf1ee13e84f420b","type":"ClientCode","z":"5f0c36ed4bd03058","g":"f02d93a56502e483","name":"deploy","clientcode":"RED.actions.invoke(\"core:deploy-flows\")","format":"javascript","x":1056.1678827571582,"y":1809.7345540732367,"wires":[[]]},{"id":"b0271a128bbbe506","type":"websocket-listener","path":"/3dflows/ws","wholemsg":"false"}]