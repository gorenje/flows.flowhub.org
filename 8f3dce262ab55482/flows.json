[{"id":"8f3dce262ab55482","type":"tab","label":"[NodeDev] ETLpipe nodes","disabled":false,"info":"### WIP\n\nNothing to see here.\n\n[More Here](https://discourse.nodered.org/t/etl-pipelines-with-node-red/84347).\n\n## TODOs\n\n- [ ] HTML UIs for all nodes\n\n- [ ] POST support for web2disk\n- [ ] header support for web2disk\n- [x] GET support for web2disk\n\n- [ ] Unzip support for disk2stream\n- [x] tar.gz support for disk2stream\n- [x] tar.bz2 support for disk2stream\n- [x] tar.xz support for disk2stream\n- [x] tar support for disk2stream\n- [ ] rename etltarball to disk2stream and merge with zip functionality\n\n- [x] support for streaming jsonl files\n- [x] gz decompress for jsonl\n- [x] bz2 decompress for jsonl\n- [x] xz decompress for jsonl\n\n- [ ] testing \n- [ ] create test data of various archive formats\n","env":[]},{"id":"c462945c139dbafe","type":"group","z":"8f3dce262ab55482","name":"Step 1: Import flow for local development","style":{"label":true},"nodes":["3c45c1dccdeac443"],"x":159,"y":307,"w":472,"h":82},{"id":"5b288cd9473f63e0","type":"group","z":"8f3dce262ab55482","name":"retart node-red when nodes are reinstalled","style":{"label":true},"nodes":["384b096abb47fac0","f3731d4987bbf415","bb7efc4b118d8778","9f4ee4553f84054a","6ed386fb7b3f0938"],"x":1828,"y":281,"w":365,"h":383},{"id":"f79bf88175981b0a","type":"group","z":"8f3dce262ab55482","name":"node templates","style":{"label":true},"nodes":["b4128506c1ab2e5c","cf2a6699a6e259a2","14331085374f7f2a"],"x":139,"y":489,"w":192,"h":211},{"id":"cf2a6699a6e259a2","type":"NodeFactory","z":"8f3dce262ab55482","g":"f79bf88175981b0a","name":"web2disk","nodename":"web2disk","color":"#C7E9C0","hasbutton":false,"hasinput":true,"outputcount":1,"category":"etl","summary":"Take a web request and store the contents directly to disk","description":"Store web content directly to disk.","icon":"font-awesome/fa-database","frt2bakcomm":false,"bak2frtcomm":false,"createmanifest":true,"isplugin":false,"x":225,"y":530,"wires":[[]]},{"id":"90771c1b460315bf","type":"PkgFile","z":"8f3dce262ab55482","name":"web2disk.js","filename":"nodes/web2disk.js","format":"javascript","syntax":"mustache","template":"module.exports = async function(RED) {\n  \n  const { got } = await import('got')\n  const { stream } = await import('node:stream')\n  const { pipeline } = await import('node:stream/promises')\n  const fs = await import('node:fs')\n  var path = require(\"node:path\");\n  const fsex = require('fs-extra')\n\n  function Coreweb2diskFunctionality(config) {\n    RED.nodes.createNode(this,config);\n\n    var node = this;\n    var cfg = config;\n\n    node.on('close', function() {\n      node.status({});\n    });\n\n    node.on(\"input\", async function(msg, send, done) {\n        try {\n\n          var dir = path.dirname(msg.filename);\n          try {\n            fsex.ensureDirSync(dir);\n          } catch (err) {\n            node.error(RED._(\"web2disk.errors.createfail\", { error: err.toString(), dir: dir }), msg);\n            done();\n            return;\n          }\n\n          var writestream = fs.createWriteStream(msg.filename).on('open', () => {\n            node.status({ fill: \"blue\", shape: \"ring\", text: \"started\" });\n          }).on('close', () => {\n            node.status({ fill: \"green\", shape: \"dot\", text: \"done: \" + writestream.bytesWritten + \" bytes\"});\n            setTimeout( () => { node.status({}) }, 2500)\n            node.send(msg)\n            done()\n          })\n\n          var getstream = got.stream(msg.url).on(\"downloadProgress\", ({ transferred, total, percent }) => {\n            const percentage = Math.round(percent * 100);\n            node.status({ fill: \"yellow\", shape: \"ring\", text: \"progress: \" + percentage + \"%\"});\n          }).on(\"error\", (err) => {\n            node.status({ fill: \"red\", shape: \"dot\", text: \"error\" });\n            node.error(\"error occurred\", { ...msg, error: err })\n            done();\n          })\n\n          await pipeline(\n            getstream,\n            writestream\n          ).catch( err => {\n            node.error(\"error occurred\", { ...msg, error: err })\n            done();\n          })\n          \n        } catch ( err ) {\n          // use node.error if the node might send subsequent messages\n          node.error(\"error occurred\", { ...msg, error: err })\n          done();\n        }\n    });\n  }\n\n  RED.nodes.registerType(\"web2disk\", Coreweb2diskFunctionality);\n\n}\n","output":"str","x":1075,"y":605,"wires":[["9297833662b61489"]]},{"id":"9297833662b61489","type":"PkgFile","z":"8f3dce262ab55482","name":"web2disk.html","filename":"nodes/web2disk.html","format":"html","syntax":"mustache","template":"<script type=\"text/javascript\">\n(function(){\n  \n\n  function frontendSupportFunction() {\n  }\n\n  var functTwo = (arg) => {\n\n  };\n  \n  RED.nodes.registerType('web2disk',{\n    color: '#C7E9C0',\n    icon: \"font-awesome/fa-database\",\n    category: 'etl',\n    defaults: {\n      name: {\n        value:\"\",\n      },\n    },\n\n    inputs: 1,\n\n    outputs: 1,\n\n    label: function() {\n      return (this.name || this._def.paletteLabel);\n    },\n\n    labelStyle: function() {\n      return this.name?\"node_label_italic\":\"\";\n    },\n\n    onpaletteadd: function() {\n    },\n\n    oneditprepare: function() {\n    },\n\n    oneditcancel: function() {\n    },\n\n    oneditsave: function() {\n    },\n\n    onpaletteremove: function() {\n    },\n\n\n\n  });\n})();\n</script>\n\n<script type=\"text/html\" data-template-name=\"web2disk\">\n  <div class=\"form-row\">\n    <label for=\"node-input-name\"><i class=\"fa fa-tag\"></i> <span data-i18n=\"node-red:common.label.name\"></span></label>\n    <input type=\"text\" id=\"node-input-name\" data-i18n=\"[placeholder]node-red:common.label.name\">\n  </div>\n</script>\n","output":"str","x":1085,"y":656.3333333333334,"wires":[["3a2adb521adbfba4"]]},{"id":"3a2adb521adbfba4","type":"PkgFile","z":"8f3dce262ab55482","name":"Locale: web2disk.json","filename":"nodes/locales/en-US/web2disk.json","format":"json","syntax":"mustache","template":"{\n  \"web2disk\": {\n\n\n    \"label\": {\n      \"hello\": \"world\"\n    },\n\n    \"errors\": {\n      \"createfail\": \"failed to created directory '__dir__': __error__\"\n    },\n    \"tip\": {\n\n    },\n    \"status\": {\n      \"waiting\": \"Waiting for Godot\",\n      \"timeout\": \"No more time to waiting\"\n    }\n  }\n}\n","output":"str","x":1105,"y":707.6666666666667,"wires":[["b0b9c397a0cd885c"]]},{"id":"b0b9c397a0cd885c","type":"PkgFile","z":"8f3dce262ab55482","name":"Locale: web2disk.html","filename":"nodes/locales/en-US/web2disk.html","format":"html","syntax":"mustache","template":"<script type=\"text/html\" data-help-name=\"web2disk\">\n  <p>Take a web request and store the contents directly to disk</p>\n  Store web content directly to disk.\n</script>\n","output":"str","x":1105,"y":759,"wires":[["d9c0bc207495f2d7"]]},{"id":"cbe757e143e8a859","type":"PkgFile","z":"8f3dce262ab55482","name":"LICENSE","filename":"LICENSE","format":"text","syntax":"mustache","template":"# LICENSE\n\nLicense texts comes here.\n\n","output":"str","x":816,"y":353,"wires":[["0f83052c897604e9"]]},{"id":"0f83052c897604e9","type":"PkgFile","z":"8f3dce262ab55482","name":"README.md","filename":"README.md","format":"markdown","syntax":"mustache","template":"# ETL nodes\n\nA collection of nodes to make constructing ETL pipelines simpler and effective in Node-RED.","output":"str","x":826,"y":413.3333333333333,"wires":[["5f93d8ebbc7cd0eb"]]},{"id":"5f93d8ebbc7cd0eb","type":"PkgFile","z":"8f3dce262ab55482","name":"CHANGELOG.md","filename":"CHANGELOG.md","format":"markdown","syntax":"mustache","template":"# Changelog\nAll notable changes to this project will be documented in this file.\n\n\n## [0.0.1]\n### Initial version\n\n**Note:** The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/), and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).\n","output":"str","x":846,"y":473.66666666666663,"wires":[["a55b55e0c02b8387"]]},{"id":"a55b55e0c02b8387","type":"PkgFile","z":"8f3dce262ab55482","name":"package.json","filename":"package.json","format":"json","syntax":"mustache","template":"{\n  \"name\" : \"{{{ pname }}}\",\n  \"version\": \"{{{ pversion }}}\",\n  \"dependencies\": {\n    \"got\": \"^13\",\n    \"fs-extra\": \"^11.2.0\",\n    \"pako\": \"^2.1.0\",\n    \"tar-stream\": \"^3.1.6\",\n    \"streamx\": \"^2.15.5\",\n    \"lzma-native\": \"^8.0.6\",\n    \"file-type\": \"^18.7.0\",\n    \"unbzip2-stream\": \"^1.4.3\"\n  },\n\n  \"description\": \"{{{ pdescription }}}\",\n  \"keywords\": [\n    \"node-red\"\n  ],\n\n  \"license\": \"Don't do evil.\",\n  \"homepage\": \"https://github.com/{{ githubowner }}/{{ githubrepo }}#readme\",\n  \"author\": \"{{{ pauthorname }}} <{{{ pauthoremail }}}>\",\n  \"engines\": {\n    \"node\": \">=16\"\n  },\n\n  \"node-red\" : {\n    \"version\": \">=3.0.0\",\n    \"nodes\": {\n       \"web2disk\": \"nodes/web2disk.js\",\n       \"disk2stream\": \"nodes/disk2stream.js\",\n       \"jsonl\": \"nodes/jsonl.js\",\n       \"etltarball\": \"nodes/etltarball.js\"\n    }\n  },\n\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"https://github.com/{{ githubowner }}/{{ githubrepo }}.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/{{ githubowner }}/{{ githubrepo }}\"\n  }\n}\n","output":"str","x":826,"y":534,"wires":[["90771c1b460315bf"]]},{"id":"33cf12809017b483","type":"NodeDevOps","z":"8f3dce262ab55482","name":"","pname":"@gregoriusrippenstein/node-red-contrib-etl-tools","pversion":"0.0.31","pauthorname":"Gerrit Riessen","pauthoremail":"gerrit@openmindmap.org","pdescription":"Nodes for making ETL pipeline construction simpler in Node-RED.","noderedinstall":true,"randompackagename":false,"ignore_package_check":false,"gitcommit":false,"gitcheckforchange":false,"githubowner":"gorenje","githubrepo":"node-red-contrib-etl-tools","githubbranch":"main","githubauthor":"Gerrit Riessen","githubauthoremail":"gerrit@openmindmap.org","githubmessage":"initial commit","npmpublish":false,"npmunpublish":false,"npmotp":"","x":551,"y":256,"wires":[["cbe757e143e8a859"]]},{"id":"e45c5aa3bf082242","type":"link out","z":"8f3dce262ab55482","name":"link out 135","mode":"link","links":["963dfb765b0d9849"],"x":1441,"y":1116,"wires":[]},{"id":"3c45c1dccdeac443","type":"FlowHubPull","z":"8f3dce262ab55482","g":"c462945c139dbafe","name":"","notab":false,"flowid":"d0506e991d512ace","flowname":"[Introspection] Develop Node-RED nodes in Node-RED","flowrevision":"","x":395,"y":348,"wires":[[]]},{"id":"b4128506c1ab2e5c","type":"NodeFactory","z":"8f3dce262ab55482","g":"f79bf88175981b0a","name":"disk2stream","nodename":"disk2stream","color":"#C7E9C0","hasbutton":false,"hasinput":true,"outputcount":1,"category":"etl","summary":"Take content from disk and generate a stream of messages from it.","description":"Take content from disk and generate a stream of messages from it.","icon":"font-awesome/fa-sign-out","frt2bakcomm":false,"bak2frtcomm":false,"createmanifest":false,"isplugin":false,"x":235,"y":594.5,"wires":[[]]},{"id":"14331085374f7f2a","type":"NodeFactory","z":"8f3dce262ab55482","g":"f79bf88175981b0a","name":"jsonl","nodename":"jsonl","color":"#C7E9C0","hasbutton":false,"hasinput":true,"outputcount":1,"category":"etl","summary":"Json Lines support for Node-RED","description":"Json Lines support for Node-RED","icon":"font-awesome/fa-fighter-jet","frt2bakcomm":false,"bak2frtcomm":false,"createmanifest":false,"isplugin":false,"x":215,"y":659,"wires":[[]]},{"id":"d9c0bc207495f2d7","type":"PkgFile","z":"8f3dce262ab55482","name":"disk2stream.js","filename":"nodes/disk2stream.js","format":"javascript","syntax":"mustache","template":"module.exports = function(RED) {\n  function Coredisk2streamFunctionality(config) {\n    RED.nodes.createNode(this,config);\n\n    var node = this;\n    var cfg = config;\n\n    node.on('close', function() {\n      node.status({});\n    });\n\n    /* msg handler, in this case pass the message on unchanged */\n    node.on(\"input\", function(msg, send, done) {\n        // How to send a status update\n        node.status({ fill: \"green\", shape: \"ring\", text: \"status set\" });\n\n        // Send a message and how to handle errors.\n        try {\n          try {\n            send(msg);\n            done();\n          } catch ( err ) {\n            // use node.error if the node might send subsequent messages\n            node.error(\"error occurred\", { ...msg, error: err })\n            done();\n          }\n        } catch (err) {\n          // use done if the node won't send anymore messages for the\n          // message it received.\n          msg.error = err\n          done(err.message, msg)\n        }\n    });\n  }\n\n  RED.nodes.registerType(\"disk2stream\", Coredisk2streamFunctionality);\n\n}\n","output":"str","x":682,"y":815,"wires":[["bc37e137e5ee5362"]]},{"id":"bc37e137e5ee5362","type":"PkgFile","z":"8f3dce262ab55482","name":"disk2stream.html","filename":"nodes/disk2stream.html","format":"html","syntax":"mustache","template":"<script type=\"text/javascript\">\n(function(){\n  \n\n  function frontendSupportFunction() {\n  }\n\n  var functTwo = (arg) => {\n\n  };\n  \n  RED.nodes.registerType('disk2stream',{\n    color: '#C7E9C0',\n    icon: \"font-awesome/fa-sign-out\",\n    category: 'etl',\n    defaults: {\n      name: {\n        value:\"\",\n      },\n    },\n\n    inputs: 1,\n\n    outputs: 1,\n\n    label: function() {\n      return (this.name || this._def.paletteLabel);\n    },\n\n    labelStyle: function() {\n      return this.name?\"node_label_italic\":\"\";\n    },\n\n    onpaletteadd: function() {\n    },\n\n    oneditprepare: function() {\n    },\n\n    oneditcancel: function() {\n    },\n\n    oneditsave: function() {\n    },\n\n    onpaletteremove: function() {\n    },\n\n\n\n  });\n})();\n</script>\n\n<script type=\"text/html\" data-template-name=\"disk2stream\">\n  <div class=\"form-row\">\n    <label for=\"node-input-name\"><i class=\"fa fa-tag\"></i> <span data-i18n=\"node-red:common.label.name\"></span></label>\n    <input type=\"text\" id=\"node-input-name\" data-i18n=\"[placeholder]node-red:common.label.name\">\n  </div>\n</script>\n","output":"str","x":682,"y":865,"wires":[["c4a558decc2dcbac"]]},{"id":"c4a558decc2dcbac","type":"PkgFile","z":"8f3dce262ab55482","name":"Locale: disk2stream.json","filename":"nodes/locales/en-US/disk2stream.json","format":"json","syntax":"mustache","template":"{\n  \"disk2stream\": {\n\n\n    \"label\": {\n      \"hello\": \"world\"\n    },\n\n    \"errors\": {\n\n    },\n    \"tip\": {\n\n    },\n    \"status\": {\n      \"waiting\": \"Waiting for Godot\",\n      \"timeout\": \"No more time to waiting\"\n    }\n  }\n}\n","output":"str","x":702,"y":915,"wires":[["6700235e74503e80"]]},{"id":"6700235e74503e80","type":"PkgFile","z":"8f3dce262ab55482","name":"Locale: disk2stream.html","filename":"nodes/locales/en-US/disk2stream.html","format":"html","syntax":"mustache","template":"<script type=\"text/html\" data-help-name=\"disk2stream\">\n  <p>Take content from disk and generate a stream of messages from it.</p>\n  Take content from disk and generate a stream of messages from it.\n</script>\n","output":"str","x":702,"y":965,"wires":[["5edeed4361013277"]]},{"id":"5edeed4361013277","type":"PkgFile","z":"8f3dce262ab55482","name":"jsonl.js","filename":"nodes/jsonl.js","format":"javascript","syntax":"mustache","template":"module.exports = async function(RED) {\n  \n  const readline = require('node:readline');\n  const path = require( 'node:path')\n  const fs = await import('node:fs')\n  const lzmaNative = require('lzma-native');\n  const zlib = require('node:zlib')\n  var bz2 = require('unbzip2-stream');\n\n  function CorejsonlFunctionality(config) {\n    RED.nodes.createNode(this,config);\n\n    var node = this;\n    var cfg = config;\n\n    node.on('close', function() {\n      node.status({});\n    });\n\n    /* msg handler, in this case pass the message on unchanged */\n    node.on(\"input\", function(msg, send, done) {\n\n        if (!msg.hasOwnProperty('filename')) {\n          done(RED._(\"jsonl.error.filename_not_set\"), msg)\n          return\n        }\n\n        if ( !fs.existsSync(msg.filename) ) {\n          done(RED._(\"jsonl.error.file_does_not_exist\", { filename: msg.filename }), msg)\n          return\n        }\n        \n        // Send a message and how to handle errors.\n        try {\n\n          var strm = fs.createReadStream(msg.filename)\n          var filetype = (msg.type || path.extname(msg.filename)).replace(/^[.]/, \"\")\n          \n          switch (filetype) {\n            case 'gz':\n              var gz = zlib.createGunzip()\n              strm = strm.pipe(gz)\n              break\n\n            case 'xz':\n              var decomp = lzmaNative.createDecompressor();\n              strm = strm.pipe(decomp)\n              break\n\n            case 'bz2':\n              strm = strm.pipe(bz2())\n              break\n\n            case 'jsonl':\n              break\n\n            default:\n              done(RED._(\"jsonl.error.unsupported_file_type\", { type: filetype }), msg)\n              return\n          }\n          \n          const rl = readline.createInterface({\n            input: strm,\n            historySize: 0,\n          }); \n\n          var cnt = 0;\n\n          rl.on('line', (line) => {\n            if ( line && line != \"\" ) {\n              if ( cnt == 0) {\n                node.status({ fill: \"blue\", shape: \"ring\", text: \"started\" })\n              }\n\n              if ((cnt += 1) % 10000 == 0) {\n                node.status({ fill: \"yellow\", shape: \"ring\", text: \"\" + cnt + \" lines\" })\n              }\n              var m = RED.util.cloneMessage(msg);\n\n              try {\n                m.payload = JSON.parse(line)\n              } catch ( err ) {\n                m.err = err\n                m.line = line\n                m.payload = undefined\n              }\n\n              send(m,false)\n            }\n          })\n\n          rl.on('close', () => {\n            var m = RED.util.cloneMessage(msg);\n\n            node.status({ fill: \"green\", shape: \"dot\", text: \"done: seen \" + cnt + \" files\" })\n            setTimeout( () => { node.status({}) }, 2000);\n\n            m.complete = true\n            send(m, false)\n            done()\n          })\n\n        } catch (err) {\n          // use done if the node won't send anymore messages for the\n          // message it received.\n          msg.error = err\n          done(err.message, msg)\n        }\n    });\n  }\n\n  RED.nodes.registerType(\"jsonl\", CorejsonlFunctionality);\n\n}\n","output":"str","x":1144,"y":854,"wires":[["bd7f65953146e64a"]]},{"id":"bd7f65953146e64a","type":"PkgFile","z":"8f3dce262ab55482","name":"jsonl.html","filename":"nodes/jsonl.html","format":"html","syntax":"mustache","template":"<script type=\"text/javascript\">\n(function(){\n  \n\n  function frontendSupportFunction() {\n  }\n\n  var functTwo = (arg) => {\n\n  };\n  \n  RED.nodes.registerType('jsonl',{\n    color: '#C7E9C0',\n    icon: \"font-awesome/fa-fighter-jet\",\n    category: 'etl',\n    defaults: {\n      name: {\n        value:\"\",\n      },\n    },\n\n    inputs: 1,\n\n    outputs: 1,\n\n    label: function() {\n      return (this.name || this._def.paletteLabel);\n    },\n\n    labelStyle: function() {\n      return this.name?\"node_label_italic\":\"\";\n    },\n\n    onpaletteadd: function() {\n    },\n\n    oneditprepare: function() {\n    },\n\n    oneditcancel: function() {\n    },\n\n    oneditsave: function() {\n    },\n\n    onpaletteremove: function() {\n    },\n\n\n\n  });\n})();\n</script>\n\n<script type=\"text/html\" data-template-name=\"jsonl\">\n  <div class=\"form-row\">\n    <label for=\"node-input-name\"><i class=\"fa fa-tag\"></i> <span data-i18n=\"node-red:common.label.name\"></span></label>\n    <input type=\"text\" id=\"node-input-name\" data-i18n=\"[placeholder]node-red:common.label.name\">\n  </div>\n</script>\n","output":"str","x":1144,"y":904,"wires":[["d33477933bf0aa5f"]]},{"id":"d33477933bf0aa5f","type":"PkgFile","z":"8f3dce262ab55482","name":"Locale: jsonl.json","filename":"nodes/locales/en-US/jsonl.json","format":"json","syntax":"mustache","template":"{\n  \"jsonl\": {\n\n\n    \"label\": {\n      \"hello\": \"world\"\n    },\n\n    \"error\": {\n      \"filename_not_set\": \"filename property not set\",\n      \"file_does_not_exist\": \"File '__filename__' does not exist\",\n      \"unsupported_file_type\": \"File type '__type__' is not supported\"\n    },\n    \n    \"tip\": {\n\n    },\n    \"status\": {\n      \"waiting\": \"Waiting for Godot\",\n      \"timeout\": \"No more time to waiting\"\n    }\n  }\n}\n","output":"str","x":1164,"y":954,"wires":[["cd6686838ad1c837"]]},{"id":"cd6686838ad1c837","type":"PkgFile","z":"8f3dce262ab55482","name":"Locale: jsonl.html","filename":"nodes/locales/en-US/jsonl.html","format":"html","syntax":"mustache","template":"<script type=\"text/html\" data-help-name=\"jsonl\">\n  <p>Json Lines support for Node-RED</p>\n  Json Lines support for Node-RED\n</script>\n","output":"str","x":1164,"y":1004,"wires":[["d2f73ade6ee25bd0"]]},{"id":"158279c5b9c1b7a3","type":"catch","z":"8f3dce262ab55482","name":"","scope":null,"uncaught":false,"x":1830,"y":119,"wires":[["8011e6ef1e7d0570"]]},{"id":"8011e6ef1e7d0570","type":"debug","z":"8f3dce262ab55482","name":"debug 172","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":1828,"y":161,"wires":[]},{"id":"384b096abb47fac0","type":"inject","z":"8f3dce262ab55482","g":"5b288cd9473f63e0","name":"kill node-red in a docker container","props":[],"repeat":"","crontab":"","once":false,"onceDelay":0.1,"topic":"","x":2014,"y":322,"wires":[["f3731d4987bbf415"]]},{"id":"f3731d4987bbf415","type":"exec","z":"8f3dce262ab55482","g":"5b288cd9473f63e0","command":"kill 1","addpay":"","append":"","useSpawn":"false","timer":"","winHide":false,"oldrc":false,"name":"","x":1941,"y":390,"wires":[["bb7efc4b118d8778"],["bb7efc4b118d8778"],["bb7efc4b118d8778"]]},{"id":"bb7efc4b118d8778","type":"debug","z":"8f3dce262ab55482","g":"5b288cd9473f63e0","name":"debug 174","active":true,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":1966,"y":456,"wires":[]},{"id":"9f4ee4553f84054a","type":"inject","z":"8f3dce262ab55482","g":"5b288cd9473f63e0","name":"","props":[{"p":"payload"},{"p":"topic","vt":"str"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"","payloadType":"date","x":2096,"y":579,"wires":[["6ed386fb7b3f0938"]]},{"id":"6ed386fb7b3f0938","type":"ClientCode","z":"8f3dce262ab55482","g":"5b288cd9473f63e0","name":"","clientcode":"RED.notify( \"Reload client, server restarted.\");\n\n//window.location.reload();\n","format":"javascript","x":2097,"y":623,"wires":[[]]},{"id":"d2f73ade6ee25bd0","type":"PkgFile","z":"8f3dce262ab55482","name":"etltarball.js","filename":"nodes/etltarball.js","format":"javascript","syntax":"mustache","template":"module.exports = async function(RED) {\n\n  const fs = await import('node:fs')\n  const tarStream = require('tar-stream');\n  const streamx = require('streamx');\n  const pakoGzip = require('pako');\n  const lzmaNative = require('lzma-native');\n  const zlib = require('node:zlib')\n  var bz2 = require('unbzip2-stream');\n  var path = require('node:path')\n\n  function CoretarballFunctionality(config) {\n    RED.nodes.createNode(this,config);\n\n    var node = this;\n    var cfg = config;\n\n    /*\n     * Extract tar files.\n     */\n    var extractTarFile = (stream, onStart, onFile, onFinish, onError) => {\n      const extract = tarStream.extract()\n\n      extract.on('entry', function (header, stream, next) {\n        // header is the tar header\n        // stream is the content body (might be an empty stream)\n        // call next when you are done with this entry\n\n        var buffer = [];\n\n        stream.on('data', function (data) {\n          buffer.push(data)\n        });\n\n        stream.on('end', function () {\n          //@ts-ignore\n          onFile(header.name, Buffer.concat(buffer))\n          next() // ready for next entry\n        })\n\n        stream.resume() // just auto drain the stream\n      })\n\n      extract.on('finish', function () {\n        onFinish([])\n      })\n\n      extract.on('error', onError);\n\n      try {\n        onStart()\n        stream.pipe(extract)\n      } catch (err) {\n        onError(err)\n      }\n    }\n\n    /*\n     * Close something\n     */\n    node.on('close', function() {\n      node.status({});\n    });\n\n    /* \n      * msg handler, in this case pass the message on unchanged \n      */\n    node.on(\"input\", function(msg, send, done) {\n\n      var onOtherError = (localeKey, err) => {\n        msg.error = err\n        done(RED._(localeKey), msg)\n      };\n\n      /* no filename, no dice */\n      if (!msg.hasOwnProperty('filename')) {\n        return onOtherError(\"etltarball.error.nopayload\", { message: RED._(\"etltarball.error.nopayload\") })\n      }\n\n      /** Extraction handlers **/\n      var onFile = (path, content) => {\n        var m = RED.util.cloneMessage(msg);\n        m.path = path\n        m.payload = content\n        send(m, false)\n      };\n\n      if ( msg.filecounter ) { \n        var cnt = 0;\n\n        onFile = (path, content) => {\n          if ( (cnt+=1) % 1000 == 0 ) {\n            node.status({ fill: \"yellow\", shape: \"dot\", text: \"\" + cnt + \" files\" })\n          }\n\n          var m = RED.util.cloneMessage(msg);\n          m.path = path\n          m.payload = content\n          send(m, false)\n        };\n      } \n      \n      if (msg.showfilename) { \n        onFile = (path, content) => {\n          node.status({ fill: \"yellow\", shape: \"dot\", text: path })\n\n          var m = RED.util.cloneMessage(msg);\n          m.path = path\n          m.payload = content\n          send(m, false)\n        };\n      }\n\n      var onDone = () => {\n        node.status({ fill: \"green\", shape: \"dot\", text: RED._(\"etltarball.info.complete_extraction\") })\n\n        var m = RED.util.cloneMessage(msg);\n        m.complete = true\n        send(m, false)\n\n        setTimeout(() => { node.status({}) }, 2000)\n        done();\n      };\n\n      var onTarError = (err) => {\n        node.status({ fill: \"red\", shape: \"dot\", text: RED._(\"etltarball.error.general\") })\n        msg.error = err\n        done(RED._(\"etltarball.error.untar\"), msg)\n      };\n\n      var onStart = () => {\n        node.status({ fill: \"blue\", shape: \"ring\", text: RED._(\"etltarball.info.started_extraction\") })\n      };\n      \n\n      var filetype = (msg.type || path.extname(msg.filename)).replace(/^[.]/, \"\")\n\n      switch (filetype) {\n        case 'tar.gz':\n        case 'tgz':\n          var gz = zlib.createGunzip()\n          extractTarFile(fs.createReadStream(msg.filename).pipe(gz), onStart, onFile, onDone, onTarError)\n          break\n\n        case 'tar':\n          extractTarFile(fs.createReadStream(msg.filename), onStart, onFile, onDone, onTarError)\n          break\n\n        case 'txz':\n        case 'tar.xz':\n          var decomp = lzmaNative.createDecompressor();\n          extractTarFile(fs.createReadStream(msg.filename).pipe(decomp), onStart, onFile, onDone, onTarError)\n          break\n\n        case 'tar.bz2':\n          extractTarFile(fs.createReadStream(msg.filename).pipe(bz2()), onStart, onFile, onDone, onTarError)\n          break\n          \n        default:\n          done(RED._(\"etletltarball.error.unsupported_file_type\", { type: filetype }), msg)\n          return\n      }\n    });\n  }\n\n  RED.nodes.registerType(\"etltarball\", CoretarballFunctionality);\n\n}\n","output":"str","x":670,"y":1075,"wires":[["a0a6d7d490e5e36c"]]},{"id":"a0a6d7d490e5e36c","type":"PkgFile","z":"8f3dce262ab55482","name":"etltarball.html","filename":"nodes/etltarball.html","format":"html","syntax":"mustache","template":"<script type=\"text/javascript\">\n(function(){\n  \n\n  function frontendSupportFunction() {\n  }\n\n  var functTwo = (arg) => {\n\n  };\n  \n  RED.nodes.registerType('etltarball',{\n    color: '#C7E9C0',\n    icon: \"font-awesome/fa-archive\",\n    category: 'etl',\n    defaults: {\n      name: {\n        value:\"\",\n      },\n    },\n\n    inputs: 1,\n\n    outputs: 1,\n\n    label: function() {\n      return (this.name || this._def.paletteLabel);\n    },\n\n    labelStyle: function() {\n      return this.name?\"node_label_italic\":\"\";\n    },\n\n    onpaletteadd: function() {\n    },\n\n    oneditprepare: function() {\n    },\n\n    oneditcancel: function() {\n    },\n\n    oneditsave: function() {\n    },\n\n    onpaletteremove: function() {\n    },\n\n\n\n  });\n})();\n</script>\n\n<script type=\"text/html\" data-template-name=\"etltarball\">\n  <div class=\"form-row\">\n    <label for=\"node-input-name\"><i class=\"fa fa-tag\"></i> <span data-i18n=\"node-red:common.label.name\"></span></label>\n    <input type=\"text\" id=\"node-input-name\" data-i18n=\"[placeholder]node-red:common.label.name\">\n  </div>\n</script>\n\n","output":"str","x":670,"y":1125,"wires":[["1976665454bab8f5"]]},{"id":"1976665454bab8f5","type":"PkgFile","z":"8f3dce262ab55482","name":"locales-enUS-etltarball.html","filename":"nodes/locales/en-US/etltarball.html","format":"html","syntax":"plain","template":"<script type=\"text/html\" data-help-name=\"etltarball\">\n    <p>Compress and extract tarballs in xz and gzip format.</p>\n<p>\n  Supports xz and gzip compression.\n\n<p><b>Compression</b>\n\n<p>\n  For compression, <code>msg.payload</code> is assumed to be an array containing\n  objects of the form:\n\n<p>\n  <code>\n  {<br>\n    path: \"full/path/in/tar/file.txt\",<br>\n    payload: Buffer.from(\"file contents\"),<br>\n  }<br>\n  </code>\n<p>\n  Payload is assumed to be a <code>Buffer</code> object. If <code>path</code> is not defined, the\n  entry is ignored.\n\n<p>\n  Returned is a tar archive which can then be compressed using \n  <a href=\"https://flows.nodered.org/node/@ecraneworldwide/node-red-contrib-lz4\" target=\"_blank\">Lzma</a>\n  or <a href=\"https://flows.nodered.org/node/node-red-contrib-gzip\" target=\"_blank\">Gzip</a>.\n  \n<p><b>Extraction</b>\n\n<p>\n  Extraction assumes that the msg.payload is an Buffer with\n  the contents of the tarball. Either encoded in xz format or\n  gzip format or non-encoded tar archive.\n\n<p>\n  A message is generated as each file is extracted. All data is encoded\n  in a <code>Buffer</code> object as it is not possible to distinguish between\n  binary content and text content. The message has a <code>path</code> attribute \n  for the file name and <code>payload</code> contains the buffer with the files\n  contents.\n\n<p>\n  Once all files have been extracted, one file message is sent that\n  contains <code>complete</code> set to true and <code>payload</code> being an array containing\n  all files that were extracted. Each file is represented by a hash\n  object: \n<p>\n  <code>\n  {<br>\n    path: \"full path of file\",<br>\n    payload: Buffer.from(\"object containing file contents in Buffer form\")<br>\n  }<br>\n  </code>\n\n</script>","output":"str","x":707,"y":1184,"wires":[["8acf962c94ab619c"]]},{"id":"8acf962c94ab619c","type":"PkgFile","z":"8f3dce262ab55482","name":"locales-enUS-etltarball.json","filename":"nodes/locales/en-US/etltarball.json","format":"json","syntax":"plain","template":"{\n    \"etltarball\": {\n        \"error\": {\n            \"general\": \"error occurred\",\n            \"formatnotsupported\": \"format not supported\",\n            \"untar\": \"error while untarring file\",\n            \"xzcorrupt\": \"Lzma/Xz data corrupt\",\n            \"unknownpayload\": \"type of msg.payload is not supported\",\n            \"compressfailed\": \"tar creation failed\",\n            \"nopayload\": \"no payload set on msg\",\n            \"unsupported_file_type\": \"File type '__type__' is not supported\"\n        },\n        \"info\": {\n            \"complete_extraction\": \"extraction complete\",\n            \"complete_archive\": \"archive complete\",\n            \"started_extraction\": \"started\"\n        }\n    }\n}\n","output":"str","x":711,"y":1242,"wires":[["e45c5aa3bf082242"]]}]